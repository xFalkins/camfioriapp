class Axios {

  get axios() {
    return super.axios = require('axios').default.create ({
      headers: { 'Content-Type': 'application/json' },
      baseURL: this.url,
    })
  }
  get    (path,...etc) { return this.axios.get    (_url(path),...etc) .catch(_error) }
  put    (path,...etc) { return this.axios.put    (_url(path),...etc) .catch(_error) }
  post   (path,...etc) { return this.axios.post   (_url(path),...etc) .catch(_error) }
  patch  (path,...etc) { return this.axios.patch  (_url(path),...etc) .catch(_error) }
  delete (path,...etc) { return this.axios.delete (_url(path),...etc) .catch(_error) }

  /** @type typeof _.get    */ get GET()    { return this.get    .bind (this) }
  /** @type typeof _.put    */ get PUT()    { return this.put    .bind (this) }
  /** @type typeof _.post   */ get POST()   { return this.post   .bind (this) }
  /** @type typeof _.patch  */ get PATCH()  { return this.patch  .bind (this) }
  /** @type typeof _.delete */ get DELETE() { return this.delele .bind (this) }
  /** @type typeof _.delete */ get DEL()    { return this.delete .bind (this) } //> to avoid conflicts with cds.ql.DELETE

}

const _url = (path) => {
  if (path.raw) path = String.raw(path)
  if (typeof path !== 'string') throw new Error (`Argument path is expected to be a string but got ${typeof path}`)
  if (!path.startsWith('/')) throw new Error (`Argument path is expected to start with a /`)
  return path
}

const _error = (e) => {
  if (!e.response)  throw e
  if (!e.response.data)  throw e
  if (!e.response.data.error)  throw new Error(e.message + '\n\n' + e.response.data)
  const { code, message } = e.response.data.error
  throw new Error (code && code !== 'null' ? `${code} - ${message}` : message)
}

const _ = Axios.prototype // eslint-disable-line no-unused-vars
module.exports = Axios
