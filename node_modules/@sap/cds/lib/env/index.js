const { isfile, fs } = require('../utils')
const DEFAULTS = require('./defaults'), defaults = require.resolve ('./defaults')
const user_home = require('os').homedir()
const compat = require('./compat')
const path = require('path')
const cache = {}


/**
 * Both a config inctance as well as factory for.
 */
class Config {

  /**
   * This is the one and only way to construct new instances.
   * Public API is through `cds.env.for (<context>)`
   * @param context - the app context, like 'cds' or 'your-app'
   * @returns {Config}
   */
  for (context, cwd, _force_cache_update=false, _filter_default_values=false) {
    if (!cwd) cwd = global.cds && global.cds.root || process.cwd()
    const cached = cache[cwd] || (cache[cwd] = {})

    if (_filter_default_values) {
      // never update cache without default values
      return new Config (context, cwd, false)
    }
    if(!cached[context] || _force_cache_update) {
      cached[context] = new Config (context, cwd)
    }
    return cached[context]
  }


  /**
   * Only used internally, i.e. through cds.env.for(<context>)
   */
  constructor (_context, _home, _defaults=true) {
    Object.assign (this, { _context, _home, _sources:[] })
    this.profiles = _determineProfilesFrom (process.env)
    this._profiles_defined = new Set()

    // compat requires default values
    if (_context === 'cds' && _defaults)  this.add (DEFAULTS, defaults)
    if (_context === 'cds' && _defaults)  compat (this)
    if (!_home)  return

    // 1. fill-in defaults for process.env, unless already defined
    this._add_to_process_env (_home, 'default-env.json')
    // 1.5 additional env for dev
    if (process.env.NODE_ENV !== 'production') {
      this._add_to_process_env (_home, '.env')
    }

    // 2. read config sources in defined order
    if (_context === 'cds') {
      this._load (user_home, '.cdsrc.json')
      this._load (_home, '.cdsrc.json')
    }
    this._load (_home, 'package.json', p => p[_context])
    this.add (_process_env4(_context), '{process.env}')

    // 3. link dependant services (through kind/use)
    this._link_required_services()
    // 4. complete service configurations from VCAP
    this._add_vcap_services (process.env.VCAP_SERVICES)

    // 5. Add compatibility for mtx
    if (this.requires && this.requires.db) {
      if (this.requires.multitenancy !== undefined) {
        Object.defineProperty(this.requires.db, 'multiTenant', { value: !!this.requires.multitenancy })
      }
      else if (this.requires.db.multiTenant !== undefined) this.requires.multitenancy = this.requires.db.multiTenant
    }
  }


  set roots(v) { set (this, 'roots', v) }
  get roots() {
    return this.roots = Object.values(this.folders) .concat ([ 'schema', 'services' ])
  }

  get tmp() {
    return set (this, 'tmp', require('os').tmpdir())
  }

  /**
   * Retrieves the value for a config option, specified as a property path.
   */
  get (option) {
    if (!option)  return
    return option.split('.').reduce ((p,n)=> p && p[n], this)
  }

  /**
   * Provides access to system defaults for cds env.
   */
  get defaults() { return DEFAULTS }

  /**
   * Get effective options for .odata
   */
  get effective(){
    return super.effective = require('..').compiler._options.for.env()
  }

  /**
   * For BAS only: to find out whether this is a Java or Node.js project
   */
  get "project-nature" () {
    const has_pom_xml = [this.folders.srv,'.'] .some (
      f => isfile (path.join (this._home, f, 'pom.xml'))
    )
    return has_pom_xml ? 'java' : 'nodejs'
  }

  /**
   * For BAS only: get all defined profiles (could include some from the defaults)
   */
  get "defined-profiles" () {
    return Array.from (this._profiles_defined)
  }


//////////////////////////////////////////////////////////////////////////
//
//    DANGER ZONE!
//    The following are internal APIs which can always change!
//


  /** @returns {Config} */
  _load (cwd, res, _conf=o=>o) {
    const json = _readJson (res = path.join(cwd, res))  // only support JSON
    if (json) {
      const conf  = _conf (json)
      if (conf) {
        this._sources.push (res)
        _merge (this, conf, this.profiles, this._profiles_defined)
      }
    }
    return this
  }

  /** @returns {Config} */
  add (conf, /*from:*/ _src) {
    if (!conf)  return this
    if (_src)  this._sources.push (_src)
    _merge (this, conf, this.profiles, this._profiles_defined)
    return this
  }

  _add_to_process_env (cwd, filename) {
    const file = path.resolve (cwd,filename)
    try {
      const all = require('../compile/etc/properties').read(file)
      for (const key in all) {
        if (key in process.env) continue // do not change existing env vars
        const val = all[key]
        process.env[key] = typeof val === 'string' ? val : JSON.stringify(val)
      }
      this._sources.push (file)
    } catch (e) {
      if (e instanceof SyntaxError)  console.error(`Error parsing '${file}': ${e.message}`)
      else if (e.code !== 'MODULE_NOT_FOUND')  console.error(e.message)
    }
  }

  _link_required_services () {
    const { requires } = this
    for (let each in requires)  requires[each] = _merged (each)
    function _merged (key) {
      let entry = requires [key]
      if (entry._is_merged || entry.kind === key || !(entry.kind in requires))  return entry
      else return Object.defineProperty (
        _merge ({..._merged(entry.kind)}, entry, false, false, 'cloned'),
        '_is_merged', {value:true}
      )
    }
  }

  _add_vcap_services (VCAP_SERVICES) {
    if (this.features && this.features.vcaps === false)  return
    if (!this.requires)  return
    if (!VCAP_SERVICES) return
    try {
      const vcaps = JSON.parse (VCAP_SERVICES)
      const any = _add_vcap_services_to (this, vcaps)
      if (any)  this._sources.push ('{VCAP_SERVICES}')
    } catch(e) {
      throw new Error ('[cds.env] - failed to parse VCAP_SERVICES:\n  '+ e.message)
    }
  }


//////////////////////////////////////////////////////////////////////////
//
//    FORBIDDEN ZONE!
//    The following are hacks for tests which should not exist!
//    Tests should test public APIs, not internal ones.
//    Tests should even less intrude hacks to core components
//


  // FOR TESTS ONLY! --> PLEASE: tests should test public APIs (only)
  _for_tests (...conf) {
    const env = new Config('cds')
    this._for_tests.vcaps = (vcaps) => { _add_vcap_services_to (env, vcaps)}
    // merge all configs, then resolve profiles (same as in 'for' function above)
    for (let c of [...conf].reverse())  _merge(env, c, env.profiles, env._profiles_defined)
    return env
  }
  // FOR TESTS ONLY! --> PLEASE: tests should test public APIs (only)
  _merge_with (src) {
    _merge (this, src, this.profiles, this._profiles_defined)
    return this
  }
}




//////////////////////////////////////////////////////////////////////////
//
//    Local Helpers...
//

/**
 * @returns {Config} dst
 */
function _merge (dst, src, _profiles, _profiles_defined, _clone) { // NOSONAR
  const profiled = []
  for (let p of Object.getOwnPropertyNames(src)) {
    const v = src[p]
    if (_profiles_defined && p[0] === '[')  _profiles_defined.add (p.slice(1,-1))
    if (_profiles && p[0] === '[') {
      if (_profiles.includes(p.slice(1,-1)))
        profiled.push (()=> _merge (dst, v, _profiles, _profiles_defined, _clone))
    }
    else if (typeof v === 'object' && !Array.isArray(v)) {
      if (!dst[p])  dst[p] = {}
      else if (_clone)  dst[p] = {...dst[p]}
      _merge (dst[p], v, _profiles, _profiles_defined)
    }
    else if (v !== undefined) {
      // eslint-disable-next-line no-prototype-builtins
      if (src.propertyIsEnumerable(p)) dst[p] = v
      else if (dst[p] === undefined) Object.defineProperty(dst, p, {value: v})
    }
  }
  for (let each of profiled) each()
  return dst
}

function _process_env4 (prefix) { // NOSONAR
  const {env} = process
  const PREF = prefix.toUpperCase(), my = { CONFIG: PREF+'_CONFIG', ENV: PREF+'_ENV' }
  const out = JSON.parse (env[my.CONFIG] || '{}')
  const pref_ = RegExp('^'+prefix+'[._]','i')
  for (let p in env) if (!(p in my) && pref_.test(p)) {
    const key = /[a-z]/.test(p) ? p : p.toLowerCase() //> CDS_FOO_BAR -> cds_foo_bar
    const path = key.slice(prefix.length+1) .split (key[prefix.length]) //> ['foo','bar']
    for (var o=out,next;;) {
      next = path.shift()
      if (!path.length) break
      o = o[next] || (o[next] = {})
    }
    o[next] = _value4(env[p])
  }
  return out
}

function _value4 (val) {
  if (val && val[0] === '{') try { return JSON.parse(val) } catch(e) {/* ignored */}
  if (val && val[0] === '[') try { return JSON.parse(val) } catch(e) {/* ignored */}
  if (val === 'true')  return true
  if (val === 'false')  return false
  if (!isNaN(val))  return parseFloat(val)
  return val
}


function _add_vcap_services_to (env, vcaps={}) { //NOSONAR
  let any
  for (let service in env.requires) {
    const conf = env.requires [service]
    const { credentials } = (
      conf.vcap && _fetch (conf.vcap) ||  //> alternatives, e.g. { name:'foo', tag:'foo' }
      _fetch ({ name: service })  ||
      _fetch ({ tag: env._context+':'+service }) ||
      _fetch ({ tag: conf.use || conf.kind }) || // important for hanatrial, labeled 'hanatrial', tagged 'hana'
      _fetch ({ label: conf.use || conf.kind }) ||
      {/* not found */}
    )
    // `credentials.database` is used as indicator for sqlite, so must not appear for other DBs
    if (conf.credentials && conf.use !== 'sqlite')  delete conf.credentials.database
    // Merge `credentials`.  Needed because some app-defined things like `credentials.destination` must survive.
    if (credentials)  any = conf.credentials = Object.assign ({}, conf.credentials, credentials)
  }
  return any

  function _fetch (predicate) { //NOSONAR
    const filter = _filter4 (predicate)
    for (let stype in vcaps) {
      const found = _array(vcaps,stype) .find (filter)
      if (found)  return found
    }
  }

  function _filter4 (predicate) {
    let filter;  for (let key in predicate) {
      const val = predicate[key], prev=filter, next=(
        key === 'tag' ? e => _array(e,'tags').includes (val)
        : e => val !== undefined ? e[key] === val : false
      )
      filter = prev ? e => prev(e) || next(e) : next
    }
    return filter
  }

  function _array(o,p) {
    const v = o[p]
    if (!v || Array.isArray(v))  return v || []
    throw new Error(`Expected '${p}' to be an array, but was: ${require('util').inspect(vcaps)}`)
  }

}

function _readJson (file) {
  try {
    const src = fs.readFileSync (require.resolve (file))
    return JSON.parse (src)
  } catch (e) {
    if (e instanceof SyntaxError)  console.error(`Error parsing '${file}': ${e.message}`)
    else if (e.code !== 'MODULE_NOT_FOUND')  console.error(e.message)
  }
}

function _determineProfilesFrom (env = process.env) {
  if (env.NODE_ENV !== 'production' && !/\bdevelopment\b/.test(env.CDS_ENV)) {
    if (env.CDS_ENV)  env.CDS_ENV += ',development'
    else  env.CDS_ENV = 'development'
  }
  const split = (x) => env[x] ? env[x].split (/\s*,\s*/) : []
  const profiles = [ ...split ('NODE_ENV'), ...split ('CDS_ENV') ]
  return [...new Set (profiles)]
}


function set (o,p,value) {
  Object.defineProperty (o, p, {value,configurable:true,writable:true})
  return value
}


/** @type Config & typeof DEFAULTS */
module.exports = Config.prototype.for('cds')
/* eslint no-console:0 */
