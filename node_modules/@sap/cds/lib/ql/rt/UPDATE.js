const { CXL, cds, libx } = require('./_helpers')
const $ = Object.assign

// We'll extend and replace these below...
const UPDATE =  libx.UPDATE('x').constructor
const update_where = UPDATE.prototype.where
const update_set = UPDATE.prototype.set


module.exports = cds.extend (UPDATE) .with (class {

  static _api() {
    return $((..._) => (this.new).entity(..._), {
      entity: (..._) => (this.new).entity(..._),
    })
  }

  entity (target, key) {
    this._.entity = this._target_name4 (...arguments)
    if (key) this.byKey(key)
    return this
  }

  with (...args) {
    return this.set(...args)
  }

  set (...args) { // NOSONAR
    const {_} = this

    // A tagged template string
    if (args[0].raw) {
      _add (CXL(...args).xpr, args[0].raw)
      // for (let each of _comma_separated_exprs(String.raw(...args))) {
      //   _add (cds.parse.expr(each).xpr, each)
      // }
    }

    // Alternating expr fragment / values args...
    else if (args.length > 1) {
      for (let i = 0; i < args.length; ++i) {
        const [, col, op] = /\s*([\w.]+)\s*([%*+-]?=)/.exec(args[i])
        _add ([ {ref:[col]}, op, { val: args[++i] } ])
      }
    }

    // A single expression string
    else if (typeof args[0] === 'string') {
      for (let each of _comma_separated_exprs(args[0])) {
        _add (cds.parse.expr(each).xpr, each)
      }
    }

    // A column - value / expr object
    else if (typeof args[0] === 'object') {
      update_set.call(this, ...args)
    }

    return this

    function _add (xpr, src) {
      if (!xpr) throw new Error (`Invalid UPDATE.set expression: ${src}`)
      const [lhs, op, ...rhs] = xpr
      if (!lhs.ref) throw new Error (`Invalid left-hand-side for UPDATE.set expression: ${lhs}`)
      const col = lhs.ref.join('.')
      const v = (
        op === '=' ? (rhs.length === 1 ? rhs[0] : { xpr: rhs }) :
        op.length === 2 && op[1] === '=' ? { xpr: [ lhs, op[0], ...rhs] } :
        cds.errror('Invalid operator in UPDATE.set expression: ' + op)
      )
      if (v.val) (_.data || (_.data={}))[col] = v.val
      else (_.with || (_.with={}))[col] = v
    }
  }

  where (...args) {
    if (!args[0]) return this
    if (args[0].raw) args = [CXL(...args).xpr]
    return update_where.apply(this,args)
  }
})


function _comma_separated_exprs(s) { // NOSONAR
  let all = [],
    start = 0,
    scope = 0,
    close = 0,
    stack = [close]
  for (let i = 0; i < s.length; ++i) {
    const c = s[i]
    if (c === ',' && !scope) {
      all.push(s.slice(start, i))
      start = i + 1
    } else if (c === "'") {
      while (i < s.length) {
        if (s[++i] === "'") {
          if (s[i + 1] === "'") ++i // NOSONAR
          else break
        }
      }
    } else if (c === '(') {
      scope++
      stack.unshift((close = ')'))
    } else if (c === '[') {
      scope++
      stack.unshift((close = ']'))
    } else if (c === '{') {
      scope++
      stack.unshift((close = '}'))
    } else if (c === close) {
      scope--
      stack.shift()
      close = stack[0]
    }
  }
  all.push(s.slice(start))
  return all
}
