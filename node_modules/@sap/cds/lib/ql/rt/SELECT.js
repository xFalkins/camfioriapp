const { CQL, CXL, cds, is_array, is_projection, is_function, _projection4, libx } = require('./_helpers')
const $ = Object.assign

// We'll extend and replace these below...
const SELECT = libx.SELECT.from('X').constructor
const select_columns = SELECT.prototype.columns
const select_where = SELECT.prototype.where
const select_having = SELECT.prototype.having
const select_groupBy = SELECT.prototype.groupBy
const select_orderBy = SELECT.prototype.orderBy
const select_limit = SELECT.prototype.limit


module.exports = cds.extend (SELECT) .with (class {

  static from(..._) { return (this.new).from(..._) }
  static _api() {
    return $((..._) => (this.new)._select_or_from(..._), {
      columns: (..._) => (this.new).columns(..._),
      from: (..._) => (this.new).from(..._),
      one: $((...x) => (this.new).one._select_or_from(...x),{
        columns: (..._) => (this.new).one.columns(..._),
        from: (..._) => (this.new).one.from(..._),
      }),
      distinct: $((...x) => (this.new).distinct._select_or_from(...x),{
        columns: (..._) => (this.new).distinct.columns(..._),
        from: (..._) => (this.new).distinct.from(..._),
      }),
    })
  }

  _select_or_from (cols, ...more) {
    if (!cols) return this
    else if (cols.name) return this.from (...arguments)
    else if (is_function(cols)) return select_columns.call (this, _projection4 (cols, this.entity))
    else if (is_array(cols)) return !cols[0] ? this : select_columns.call (this, cols)
    else if (!isNaN(cols)) return select_columns.apply (this,arguments) //> numbers can't be from
    else if (cols === '*') return select_columns.apply (this,arguments)
    else if (cols.raw) {
      let tts = [ ...cols ]; tts.raw = true //> because tt strings are sealed
      if (tts[0].startsWith('from ')) {   //> it's a from, with an arbitrary long CQL tail...
        tts[0] = 'SELECT '+ tts[0]
        let {SELECT} = CQL(tts, ...more)
        Object.assign (this._, SELECT)
        return this
      } else if (tts[0].includes(':')) {  //> it's a from (and needs to be handled, as it would become a cast instead)
        return this.from (String.raw(...arguments))
      } else if (tts[0][0] === '{') {     //> it's a select
        tts[0] = 'SELECT from X '+ tts[0]
        let {SELECT} = CQL(tts, ...more)
        return select_columns.call (this, SELECT.columns)
      } else {                            //> still ambiguous...
        tts[0] = 'SELECT from X { '+ tts[0]; tts[tts.length-1] += ' }'
        let {SELECT:{columns:c}} = CQL(tts, ...more)
        if (c.length > 1 || !c[0].ref) return select_columns.call (this, c)
        else cols = c[0] //> goes on below...
      }
    }
    else if (typeof cols === 'string' && cols.includes(':')) {
      return select_columns.apply (this,arguments)
    }


    // it's still unclear whether it's a select or a from case
    // -> return a proxy assuming it's a from and switching to
    // columns on a subsequent call of .from, if any.
    const {one} = this._
    return Object.defineProperties (this.from(cols, ...more), {
      from: {configurable:true,value:(..._) => {
        delete this.from; delete this._.columns; delete this._.where
        if (!one) delete this._.one
        return this.from(..._).columns(cols, ...more)
      }},
    })
  }

  columns (cols, ...more) {
    if (!cols) return this
    if (is_function(cols)) return select_columns.call (this, _projection4 (cols, this.entity))
    if (is_array(cols)) return !cols[0] ? this : select_columns.call (this, cols)
    if (cols.raw) {
      let tts = [ ...cols ]; tts.raw = true //> because tt strings are sealed
      if (tts[0][0] === '{') {
        tts[0] = 'SELECT from X '+ tts[0]
      } else {
        tts[0] = 'SELECT from X { '+ tts[0]
        tts[tts.length-1] += ' }'
      }
      let {SELECT} = CQL(tts, ...more)
      cols = SELECT.columns
    }
    return select_columns.call (this, cols, ...more)
  }

  from (target, second, third) {
    this._.from = target === '*' || this._target_ref4 (...arguments)
    if (!target.raw && second) {
      if (is_projection(second)) this.columns(second)
      else this.byKey(second)
      if (third) this.columns(third)
    }
    // REVISIT: compatibility with overly eager impl in cds-runtime
    if (!this._.columns) this._addSelectColumns (target)
    return this
  }

  limit (rows,offset) {
    if (rows === undefined) return this
    if (typeof rows === 'object') this._.limit = rows
    else select_limit.call(this,rows,offset)
    return this
  }

  get distinct() {
    this._.distinct = true
    return this
  }
  get one() {
    this._.one = true
    return this
  }

  redirectTo (entity) {
    return this.clone().from(entity)
  }

  expand (ref, cols, exp = 'expand') {
    const { SELECT } = this,
      columns = SELECT.columns || (SELECT.columns = [])
    const col = { ref: ref.split('.'), [exp]: cols ? _projection4(cols) : ['*'] }
    columns.push(col)
    return this
  }

  inline (ref, cols) {
    return this.expand(ref, cols, 'inline')
  }

  where(...args) {
    if (!args[0]) return this
    if (args[0].raw) args = [CXL(...args).xpr]
    return select_where.apply(this,args)
  }

  having(...args) {
    if (args[0].raw) { this._.having = CXL(...args).xpr; return this }
    return select_having.apply(this,args)
  }

  groupBy (...args) {
    if (args[0].raw) {
      let tts = [ ...args ]; tts.raw = true //> because tt strings are sealed
      tts[0] = 'SELECT from X group by '+ tts[0]
      this._.groupBy = CQL(...tts).SELECT.groupBy
      return this
    }
    return select_groupBy.apply(this,args)
  }

  orderBy (...args) {
    if (args[0].raw) {
      let tts = [ ...args ]; tts.raw = true //> because tt strings are sealed
      tts[0] = 'SELECT from X order by '+ tts[0]
      this._.orderBy = CQL(...tts).SELECT.orderBy
      return this
    }
    return select_orderBy.apply(this,args)
  }

  foreach(callback) {
    return this.then((rows) => rows.map(callback))
  }

})
