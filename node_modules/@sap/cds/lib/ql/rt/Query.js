const { cds, _predicate4, libx } = require('./_helpers')
const { BaseStatement } = libx
const { inspect } = require('util')

module.exports = cds.extend (BaseStatement) .with (class {

  static get new() {
    const q = new this, cmd = this.name.toUpperCase() // NOSONAR
    return Object.defineProperties (q, {_:{value:q[cmd]}, cmd:{value:cmd}})
  }

  /** Binds this query to be executed with the given service */
  bind (srv) {
    return Object.defineProperty (this,'_srv',{value:srv})
  }

  /** Turns all queries into Thenables which execute with primary db by default */
  then (r,e) {
    return (this._srv || cds.db) .run (this) .then (r,e)
  }

  /** Beautifies output in REPL */
  [inspect.custom]() {
    const colors = process.env.CDS_TERM_COLORS !== false
    const cmd = this.cmd
    return (
      `{ ${cmd}: ` +
      inspect(this[cmd], { colors, depth: 22 })
        .replace(/^\w*\s/, '')
        .replace(
          /{ ref: \[([^\]]*)\] }/g,
          (_, ref) => '{ref:[' + ref.slice(1, -1) + ']}'
        )
        .replace(/{ val: ([^ ]*) }/g, '{val:$1}')
        .replace(/{ (xpr|ref|val): /g, '{$1:') +
      '}'
    )
  }

  _target_ref4 (target) {

    // Resolving this._target --> REVISIT: this is not reliable !!!
    Object.defineProperty (this, '_target', { value: target && (
      typeof target === 'string' ? { name: target } :
      target.name ? target : //> assumed to be a linked csn definition
      target.ref ? { name: target.ref[0] } :
      target._target || { name: undefined }
    ), configurable:true })

    return target && (
      typeof target === 'string' ? cds.parse.path(target) :
      target.ref    ? target :
      target.SELECT ? target :
      target.SET    ? target :
      target.raw    ? cds.parse.path(...arguments) :
      target.name   ? {ref:[target.name]} : 0
    )
    || cds.error.expected `${{target}} to be an entity path string, a CSN definition, a {ref}, a {SELECT}, or a {SET}`
  }

  //> REVISIT: should we rather have consistent .from/.entity/.into in CQN?
  _target_name4 (target) {
    const {ref} = this._target_ref4 (target)
    return ref.length === 1 && typeof ref[0] === 'string' ? ref[0] : {ref}
  }

  byKey(key) {
    if (this.SELECT) this.SELECT.one = true
    if (typeof key !== 'object') {
      const e = this._target
      const ID = e.keys ? Object.keys(e.keys)[0] : 'ID'
      key = { [ID]: key }
    }
    this._.where = _predicate4 (key)
    return this
  }

  clone() {
    const q = this.constructor.new
    Object.assign (q._, this._)
    return this._srv ? q.bind(this._srv) : q
  }

})
