const is_projection = (x) => is_function(x) || is_array(x)
const is_function = (x) => typeof x === 'function'
const is_array = (x) => Array.isArray(x) && !x.raw

const cds = require('../../index')
const { CQL, CXL } = cds.parse

module.exports = {
  libx: require('../../../libx/_runtime').statements,
  is_projection, is_array, is_function,
  _projection4, _predicate4,
  CQL, CXL, cds,
}


/* eslint no-unused-vars: off */
function _projection4(x, entity) { // NOSONAR
  if (!x || x === '*') return ['*']
  if (is_projection(x[0])) x = x[0]
  if (is_array(x)) return x.map((c) => (c.ref ? c : { ref: c.split('.') }))
  if (typeof x === 'function') {
    const columns = []
    x(
      new Proxy(x, {
        // handle top-level projections or subselects such as
        // (foo)=>{ foo('*'), foo(SELECT...).as('bar') }
        apply: (_, __, args, ...more) => {
          if (!args.length) args = ['*']
          let [x] = is_array(args[0]) || args[0].raw ? args[0] : args
          if (x === '.*') x = '*'
          columns.push(x)
          return { as: (alias) => (x.as = alias) }
        },
        // handle top-level paths like (foo)=>{ foo.bar }
        get: (_, p) => {
          const col = { ref: [p] }
          columns.push(col)
          const nested = new Proxy(x, {
            // handle n-fold paths like (foo)=>{ foo.bar.car }
            get: (_, p) => {
              if (p === 'where') return (x) => ((col.where = _predicate4(x)), nested)
              if (p === 'as') return (alias) => ((col.as = alias), nested)
              else col.ref.push(p)
              return nested
            },
            // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
            apply: (_, __, args) => {
              const [a, b] = args
              if (!a) col.expand = ['*']
              else if (a.raw) {
                if (a[0] === '*') col.expand = ['*']
                else if (a[0] === '.*') col.inline = ['*']
                else {
                  let tts = [...a] //> tts are sealed
                  tts[0] = 'SELECT '+ col.ref[col.ref.length-1] +' '+ tts[0]
                  tts[tts.length-1] += ' from X'
                  let {SELECT} = CQL(...tts)
                  Object.assign (col, SELECT.columns[0])
                }
              }
              else if (a === '*') col.expand = ['*']
              else if (a === '.*') col.inline = ['*']
              else {
                let x = (col[/^\(?_\b/.test(a) ? 'inline' : 'expand'] = _projection4(args))
                if (b && b.levels)
                  while (--b.levels) x.push({ ...col, expand: (x = [...x]) })
              }
              return nested
            },
          })
          return nested
        },
      })
    )
    return columns
  }
  else throw new Error('SELECT w/ invalid projection argument: ' + JSON.stringify(x))
}


/**
 * Helper to create a predicate from a feather object
 */
function _predicate4 (o,...more) {
  if (o.raw) return CXL(o,...more).xpr
  const predicates = []
  for (let each in o) {
    predicates.push('and', { ref: each.split('.') }, '=', { val: o[each] })
  }
  return predicates.slice(1)
}
