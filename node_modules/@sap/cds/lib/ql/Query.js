const set = (o,p,v) => Object.defineProperty (o,p, { value:v, configurable:true })
const { inspect } = module.require('util')
const {cds} = global

module.exports = class Query {

  constructor(_={}) {
    const cmd = this.constructor.name
    set (this, '_', this[cmd] = _)
    set (this, 'cmd', cmd)
  }

  target(e) {
    return set (this,'_target', e.name ? e : e._target || { name: e })._target
  }

  bind(srv) {
    return set (this,'_srv',srv)
  }

  /** Turns all queries into Thenables which execute with primary db by default */
  then(r,e) {
    let {_promised} = this; if (!_promised) {
      const srv = this._srv || this._target._service && cds.services[this._target._service.name] || cds.db
      set (this,'_promised', _promised = srv.run(this))
    }
    return _promised.then(r,e)
  }

  async foreach(cb) {
    return (await this).map(cb)
  }

  clone() {
    return new this.constructor({ ...this._ })
  }

  valueOf (qo='Query on') {
    return qo + ' ' + this._target.name.replace(/[.:]/g, '_') + ' '
  }

  // beautify output in REPL
  [inspect.custom]() {
    const colors = process.env.CDS_TERM_COLORS !== false
    const cmd = this.cmd
    return (
      `{ ${cmd}: ` +
      inspect(this[cmd], { colors, depth: 22 })
        .replace(/^\w*\s/, '')
        .replace(
          /{ ref: \[([^\]]*)\] }/g,
          (_, ref) => '{ref:[' + ref.slice(1, -1) + ']}'
        )
        .replace(/{ val: ([^ ]*) }/g, '{val:$1}')
        .replace(/{ (xpr|ref|val): /g, '{$1:') +
      '}'
    )
  }
}
