// TEST = o x:(expr) o {return x}

//--------------------------------------------------------------------------
// Queries

  columns
    = cols:(c:column {return[c]}) tail:(COMMA c:column {cols.push(c)})*
    {return cols}

	column
    = "*"
      / r:ref ".*" { r.inline=['*']; return r }
      / x:expr ((_"as"i_/_) a:name {x.as=a})? {return x}

  obyx  = x:expr
    (_ ad:("ASC"i / "DESC"i) {x.sort=ad.toLowerCase()} )?
    (_"NULLS"i_ fl:("FIRST"i / "LAST"i) {x.nulls=fl.toLowerCase()} )?
    {return x}

  //

//--------------------------------------------------------------------------
// Expressions

  expr "an expression" // returns one of {val:...}, {ref:...} or {xpr:...}
    = xpr:_xpr ( ao:(and/or) y:_xpr {xpr.push(ao,...y)})*
    { return xpr.length === 1 ? xpr[0] : {xpr} }

    _xpr //> internal rule to construct a single expressions as arrays

      = o:unary_operator b:operand
      {return [o,b] }

      / a:operand o"?"o b:operand o":"o c:operand
      {return ['case','when',a,'then',b,'else',c,'end'] }

      / a:operand o"?:"o b:operand
      {return [{func:'coalesce', args:[a,b]}]}

      / a:operand is? n:not? null
      {return n ? [a,'is','not','null'] : [a,'is','null']}

      / a:operand n:not? o:keyword_operator b:operand
      {return n ? [a,'not',o,b] : [a,o,b] }

      / a:operand o:binary_operator b:operand
      {return [a,o,b]}

      / a:operand
      {return [a]}


  operand
    = OPEN x:expr CLOSE {return x}
    / function
    / val
    / ref
    / list
    / param
    / unparsed

  list
    = OPEN head:expr tail:(COMMA x:expr {return x})* CLOSE
    { return {list:[head,...tail]}}

  function
    = func:$(name('.'? name)*) args:args
    {return {func,args}}

  param
    = ':' p:(name/number) {return {param:true,ref:[p]}}
    / "?" {return {param:true,ref:['?']}}

  unary_operator
    = o op:(
      "EXISTS"i !ALPHA {return 'exists'}
      / "-" !number {return '-'}
      / "+" !number {return '+'}
      / "!" {return 'not'}
      / "~"
      / not
    ) o {return op}

  binary_operator
    = o op:(
      ne / eq / le / lt / ge / gt
      / "||" / "&&" / "+=" / "-="
      / [*/%+-]
    ) o {return op}

  keyword_operator
    = o op:(
      o:( "IN"i / "BETWEEN"i / "LIKE"i / "GLOB"i / "MATCH"i / "REGEXP"i )!ALPHA {return o}
      / !("as"i / and / or) n:name {return n}
    ) o {return op}

  //

  is  = o "is"i !ALPHA o {return "is"}
  not = o "not"i !ALPHA o {return "not"}
  and = o "and"i !ALPHA o {return "and"}
  or  = o "or"i !ALPHA o {return "or"}

  ne = ( "ne"i !ALPHA / is not / "!=" / "<>" ){return "!="}
  eq = ( "eq"i !ALPHA / is / "==" / "=" ){return "="}
  le = ( "le"i !ALPHA / "<=" ){return "<="}
  lt = ( "lt"i !ALPHA / "<"  ){return "<"}
  ge = ( "ge"i !ALPHA / ">=" ){return ">="}
  gt = ( "gt"i !ALPHA / ">"  ){return ">"}

  // maybe_operator "an operator" = o op:$[:!|&~\?^]+ o {return op}


//--------------------------------------------------------------------------
// Names and References


  ref "a reference"
    = head:segment tail:(o'.'o? s:segment {return s})*
      {return {ref:[head,...tail]}}

  segment
    = id:name filter:filter?
    {return !filter ? id : {id,...filter}}

  name "a name"
    = $( !DIGIT ALPHA+ )

	filter
    = o"["o one:("1:")? o ("where"_)? where:( expr / "*" )? o"]"
    {let f={where}; if(one) f.cardinality={max:1}; return f}

  args
    = OPEN a:( '*'{return['*']} / named_args / positional_args / ""{return[]} ) CLOSE
    {return a}

  named_args
    = args:(n:name COLON v:expr {return {[n]:v}})
    ( COMMA n:name COLON v:expr {args[n]=v} )*
    {return args}

  positional_args
    = head:expr tail:(COMMA x:expr {return x})*
    {return [head, ...tail]}

  //


//--------------------------------------------------------------------------
// Literals

  val "a literal value"
    = literal:literal_prefix val:string {return {val,literal}}
    / val:literal {return {val}}

  literal_prefix
    = "datetime"
    / "timestamp"
    / "date"
    / "time"

  literal
    = true / false / null
    / number
    / string
    / symbol

  number
    = x:$( [+-]? DIGIT+ ("." DIGIT+)? ("e" [+-]? DIGIT+)? )
    { return Number(x) }

  string
    = "'" s:$("''"/[^'])* "'"
    {return s.replace(/''/g,"'")}

  symbol // an enum symbol
    = "#" s:name
    {return{'#':s}}

  null  =  "null"i !ALPHA {return null}
  true  =  "true"i !ALPHA {return true}
  false = "false"i !ALPHA {return false}

  unparsed "#(...)"  = "#" u:_unparsed
  {return Object.assign(String(u.trim()),{unparsed:true})}

  _unparsed = "(" u:$( [^()] / _unparsed )* ")"o {return u}
  //> reads arbitrary input between balanced parentheses


//--------------------------------------------------------------------------
// Punctuation

  OPEN "(" = o"("o {return "("}
  CLOSE ")" = o")" {return ")"}
  COLON "a colon" = o":"o {return ":"}
  COMMA "a comma" = o","o {return ","}
  ALPHA = [_$A-Za-z0-9]
  DIGIT = [0-9]


//--------------------------------------------------------------------------
// Whitespaces and Comments

  _ "" = [ \t\n]+
  o "" = [ \t\n]*

//--------------------------------------------------------------------------
