const express = require('express')
const cds = require('./lib')

/**
 * Standard express.js bootstrapping, constructing an express `application`
 * and launching a corresponding http server using `app.listen()`.
 * Project-specific `./server.js` can overload this and react to these
 * events:
 *
 * - cds.on('bootstrap',(app)) - emitted before any middleware is added
 * - cds.on('loaded',(model)) - emitted when a model was loaded
 * - cds.on('connect',(srv)) - emitted when a service was connected
 * - cds.on('serving',(srv)) - emitted when a service was served
 * - cds.on('listening',({server,url})) - emitted when the server is listening
 *
 * @param {object} options - canonicalized options from `cds serve` cli
 * @param {boolean} options.in_memory - true if we need to bootstrap an in-memory database
 * @param {string} options.service - name of service to be served; default: 'all'
 * @param {string} options.from - filenames of models to load; default: '*'
 * @param {express.Application} options.app - filenames of models to load; default: '*'
 * @param {express.Handler} options.index - custom handler for /
 * @param {express.Handler} options.favicon - custom handler for /favicon.ico
 * @param {express.Handler} options.logger - custom request logger middleware
 * @returns Promise resolving to a Node.js http server as returned by express' `app.listen()`.
 */
module.exports = async function cds_server (options, o = { ...options, __proto__:defaults }) {

  const app = cds.app = o.app || express()
  app.serve = _app_serve                          //> app.serve allows delegating to sub modules
  cds.emit ('bootstrap',app)                      //> hook for project-local server.js

  // mount static resources and logger middleware
  if (o.static)    app.use (express.static (o.static))  //> defaults to ./app
  if (o.favicon)   app.use ('/favicon.ico', o.favicon)  //> if none in ./app
  if (o.index)     app.get ('/',o.index)                //> if none in ./app
  if (o.correlate) app.use (o.correlate)                //> request correlation
  if (o.logger)    app.use (o.logger)                   //> basic request logging
  if (o.toggler)   app.use (o.toggler)                  //> feature toggler

  // load specified models or all in project
  const csn = await cds.load (o.from||'*', {mocked:o.mocked})
  cds.model = o.from = cds.linked (cds.compile.for.odata(csn))

  // connect to essential framework services if required
  const _init = o.in_memory && (db => cds.deploy(csn).to(db,o))
  if (cds.requires.db) cds.db =  await cds.connect.to ('db') .then (_init)
  if (cds.requires.messaging)    await cds.connect.to ('messaging')
  if (cds.requires.multitenancy) await cds.mtx.in (app)

  // serve all services declared in models
  await cds.serve (o.service,o).in (app)
  await cds.emit ('served', cds.services)               //> hook for listeners

  // start http server
  const port = (o.port !== undefined) ? o.port : (process.env.PORT || 4004)
  return app.listen (port)

}


// -------------------------------------------------------------------------
// Default handlers, which can be overidden by options passed to the server
//
const defaults = {

  get static()  { return cds.env.folders.app },  //> defaults to ./app

  // default generic index.html page
  get index() {
    const index = require ('./app/index.js')
    return (_,res) => res.send (index.html)
  },

  // default favicon
  get favicon() {
    const favicon = require.resolve ('./app/favicon.ico')
    return express.static (favicon, {maxAge:'14d'})
  },

  // REVISIT: we need to align that with lib/req/context.js#L68 and remove redundancies
  // ensure correlation id and set intermediate or augment cds.context until tx opened in protocol adpater
  get correlate() {
    return (req,_,next) => {
      if (!cds.context) cds.context = {}
      const id = cds.context.id
        || req.headers['x-correlation-id'] || req.headers['x-correlationid']
        || req.headers['x-request-id'] || req.headers['x-vcap-request-id']
        || cds.utils.uuid()
      cds.context.id = req.headers['x-correlation-id'] = id
      if (!cds.context._) cds.context._ = {}
      if (!cds.context._.req) cds.context._.req = req
      next()
    }
  },

  // default request logger
  get logger() {
    const LOG = cds.log(), DEBUG = cds.debug('server')
    return (req,_,next) => {
      LOG (req.method, decodeURI(req.url))
      if (/\$batch/.test(req.url))  req.on ('dispatch', (req) => {
        LOG ('>', req.event, decodeURI(req._path), req._query||'')
        if (DEBUG && req.query) DEBUG (req.query)
      })
      next()
    }
  },

  // feature toggler
  get toggler() {
    return require('./libx/_runtime/common/toggles/alpha')(cds)
  },
}


// Helpers to delegate to imported UIs
const path = require('path')
const _app_serve = function (endpoint) { return {
  from: (pkg,folder) => {
    folder = !folder ? pkg : path.resolve(require.resolve(pkg+'/package.json'),'../'+folder)
    this.use (endpoint, express.static(folder))
    if (!endpoint.endsWith('/webapp')) (this._app_links || (this._app_links = [])) .push (endpoint)
  }
}}


// -------------------------------------------------------------------------
if (!module.parent)  module.exports ({from:process.argv[2]})
