const { fs } = require('@sap/cds-foss')
const path = require('path')

const BuildTaskHandlerEdmx = require('../buildTaskHandlerEdmx')
const { isOldJavaStack, BuildError } = require('../../util')

const { BUILD_OPTION_OUTPUT_MODE, ODATA_VERSION, ODATA_VERSION_V2,
    OUTPUT_MODE_RESULT_ONLY, FILE_EXT_CDS, SKIP_ASSERT_COMPILER_V2 } = require('../../constants')
const { INFO } = require('../../buildTaskHandler')
const DEBUG = process.env.DEBUG

const DEFAULT_COMPILE_DEST_FOLDER = path.normalize('src/main/resources/edmx')

class JavaCfModuleBuilder extends BuildTaskHandlerEdmx {
    init() {
        super.init()
        this.task.options.compileDest = path.resolve(this.task.dest, this.task.options.compileDest || DEFAULT_COMPILE_DEST_FOLDER)
    }

    async build() {
        const { src, dest } = this.task

        const odataOptions = {
            version: this.env.get(ODATA_VERSION)
        }

        if (await isOldJavaStack([src, this.buildOptions.root])) {
            if (!this._isCompilerV1() && !this.env.get(`build.${SKIP_ASSERT_COMPILER_V2}`)) {
                throw new BuildError('CDS compiler version 2 does no longer support the classic CAP Java runtime. It is recommended to migrate to the current CAP Java runtime SDK. See https://cap.cloud.sap/docs/java/migration for more.')
            }
            // default is now v4 and not v2 anymore, so warn and overwrite with v2 if using default
            if (!this.env.for('cds', this.buildOptions.root, false, true).get(ODATA_VERSION)) {
                odataOptions.version = ODATA_VERSION_V2
                this.pushMessage('Forcing OData v2 for building though the default is v4. Make sure to define OData v2 in cds configuration.', INFO)
            }

            // 'sql_mapping' and 'cds.persinstence.name' annotations are required by old java stack
            if (this.env.sql.names !== 'plain') {
                odataOptions.sql_mapping = this.env.sql.names
            }
        }

        const model = await this.model()
        if (!model) {
            return this._result
        }

        const odata = await this._compileCsn(model, this.task.options.compileDest, odataOptions)
        await this.compileEdmx(odata, this.task.options.compileDest, odataOptions)

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this._copyNativeContent(src, dest)
        }
        return this._result
    }

    async clean() {
        if (this.isStagingBuild()) {
            await super.clean()
            return
        }
        if (DEBUG) {
            this.logger.log(`Deleting build target folder ${this.task.options.compileDest}`)
        }
        await fs.remove(this.task.options.compileDest)
    }

    async _copyNativeContent(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            } else {
                const extname = path.extname(entry)
                return extname !== FILE_EXT_CDS
            }
        })
    }

    async _compileCsn(model, csnDest, compileOptions) {
        // csn for service providers
        const odataOptions = {
            ...this._options4odata(),
            ...compileOptions
        }
        const odataModel = this.cds.compile.for.odata(model, odataOptions)

        // This will als add a @source annotation containing the relative path to the origin .cds source file.
        // The @source annotation is required for correct custom handler resolution if no @impl annotation has been defined as
        // custom service handler implementations are relative to the origin .cds source files.
        // For staging builds (task.src !== task.dest) the csn.json file that is served at runtime is copied into a corresponding srv subfolder.
        // As a consequence the src folder name has to be included in the @source file name while for inplace builds (task.src === task.dest) this is not the case.
        // This ensures that the paths are relative to the cwd when executing cds run.
        const jsonOptions = {
            cwd: this.buildOptions.root,
            src: this.task.src === this.task.dest ? this.task.src : this.buildOptions.root
        }
        const extCsn = this.cds.compile.to.json(odataModel, jsonOptions)
        this._result.csn = JSON.parse(extCsn)

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            await this.write(extCsn).to(path.join(csnDest, 'csn.json'))
        }
        return odataModel
    }

    _isCompilerV1() {
        const { version } = require('@sap/cds-compiler/package.json')
        const match = version.match(/(\d+)\.?(\d*)\.?(\d*)/)
        return match && match[1] === 1
    }
}
module.exports = JavaCfModuleBuilder
