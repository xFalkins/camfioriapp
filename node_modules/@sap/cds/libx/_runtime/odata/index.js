const cds = require('../cds')
const LOG = cds.log('odata')

const fs = require('fs')
const path = require('path')
const odataPegGrammarPath = path.join(__dirname, '../../../.internal/odata2cqn/odata2cqn.pegjs')
let odataParser, peg

const _pegjsExists = () => {
  try {
    peg = require('pegjs')
    return true
  } catch (e) {
    return false
  }
}

// generate parser if grammar and pegjs are available
if (fs.existsSync(odataPegGrammarPath) && _pegjsExists() && !process.env.TRAVIS_PULL_REQUEST) {
  const odataPegGrammar = fs.readFileSync(odataPegGrammarPath, { encoding: 'utf8' })

  // generate parser object
  odataParser = peg.generate(odataPegGrammar)

  // generate parser string and asynchronously write to file
  const parserString = peg.generate(odataPegGrammar, { output: 'source', format: 'commonjs' })
  fs.writeFile(path.join(__dirname, 'odata2cqn.js'), parserString, err => {
    if (err && LOG._warn) {
      err.message = 'Unable to store generated odata2cqn grammar: ' + err.message
      LOG.warn(err)
    }
  })
} else {
  odataParser = require('./odata2cqn')
}

const { cqn2odata, getSafeNumber } = require('./cqn2odata')

const strict = {
  functions: {
    contains: 1,
    startswith: 1,
    endswith: 1,
    tolower: 1,
    toupper: 1,
    length: 1,
    indexof: 1,
    substring: 1,
    trim: 1,
    concat: 1,
    year: 1,
    month: 1,
    day: 1,
    hour: 1,
    minute: 1,
    second: 1,
    time: 1,
    now: 1
  }
}

const odata = (module.exports = {
  parse: {
    url: (url, o) => {
      const options = { safeNumber: getSafeNumber }
      if (o === 'strict' || (o && o.strict)) options.strict = strict
      return odataParser.parse(decodeURIComponent(url), options)
    },
    cqn: (cqn, kind, model) => {
      return cqn2odata(cqn, kind, model)
    }
  },
  to: {
    cqn: (url, o) => odata.parse.url(url, o),
    url: (cqn, kind, model) => odata.parse.cqn(cqn, kind, model)
  }
})
