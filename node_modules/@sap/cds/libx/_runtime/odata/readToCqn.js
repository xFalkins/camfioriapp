const cds = require('../cds')
const { findCsnTargetFor } = require('../common/utils/csn')
// REVISIT: should be cds.ql
const { SELECT } = require('../cds-services/statements')
const rewriteAsterisk = require('../common/utils/rewriteAsterisk')

const { getMaxPageSize } = require('../common/utils/page')

const _isEntityWithKeys = (entity, ref) => {
  if (!ref || !ref.id || !ref.where) return
  const keys = ref.where.reduce((res, part) => {
    if (Array.isArray(part.ref)) res.push(part.ref[0])
    return res
  }, [])
  for (const key in entity.keys) {
    if (entity.elements[key].target) continue
    if (keys.indexOf(key) === -1) return
    keys.splice(keys.indexOf(key))
  }
  return keys.length === 0
}

const _isCollection = (ref, root, model) =>
  ref.length > 1
    ? ref.slice(1).reduce((csn, _ref, i, arr) => {
        if (!csn) return false
        const seg = _ref.id || _ref
        let target = csn.elements && csn.elements[seg]
        if (!target) {
          if (csn.target) target = model.definitions[csn.target].elements[seg]
          else if (!csn.items && csn._isStructured) {
            // REVISIT: this is not tested with x4!!!
            if (csn.elements) target = csn.elements[seg]
            else if (csn.type) target = model.definitions[csn.type].elements[seg]
          }
        }
        if (i === arr.length - 1) {
          if (target && target.target) return !_isEntityWithKeys(model.definitions[target.target], _ref)
          if (target && target.items) return true
        } else return target
      }, root)
    : !_isEntityWithKeys(root, ref[0])

/*
 * uses new odata2cqn
 */
const _newReadToCQN = ({ model, namespace }, target, req) => {
  const odata = !!req.getUrlObject

  const url = odata ? req.getUrlObject().path : req.url

  const parsed = cds.odata.parse.url(url)

  const parsedTargetName = parsed.SELECT.from.ref[0].id || parsed.SELECT.from.ref[0]
  let root = target
  if (parsedTargetName !== target.name) {
    root = findCsnTargetFor(parsedTargetName, model, namespace)
    if (parsed.SELECT.from.ref[0].id) {
      parsed.SELECT.from.ref[0].id = root.name
    } else {
      parsed.SELECT.from.ref[0] = root.name
    }
  }
  const whereKeys = parsed.SELECT.from.ref[0].where
  if (whereKeys && whereKeys.length === 1) {
    whereKeys.push('=', whereKeys[0])
    for (const key in root.keys) {
      whereKeys.splice(0, 1, { ref: [key] })
    }
  }

  const cqn = SELECT.from(target.name)

  cqn.SELECT.from = parsed.SELECT.from
  if (parsed.SELECT.columns) cqn.SELECT.columns = parsed.SELECT.columns
  if (parsed.SELECT.search) cqn.SELECT.search = parsed.SELECT.search
  if (parsed.SELECT.where) cqn.SELECT.where = parsed.SELECT.where
  if (parsed.SELECT.orderBy) cqn.SELECT.orderBy = parsed.SELECT.orderBy
  if (parsed.SELECT.groupBy) cqn.SELECT.groupBy = parsed.SELECT.groupBy
  if (parsed.SELECT.count) cqn.SELECT.count = parsed.SELECT.count

  if (!_isCollection(parsed.SELECT.from.ref, root, model)) {
    cqn.SELECT.one = true
  } else if (parsed.SELECT.limit) {
    // adjust SELECT.limit based on @cds.query.limit annotations
    const rows = parsed.SELECT.limit.rows ? parsed.SELECT.limit.rows.val : Number.MAX_SAFE_INTEGER
    const offset = parsed.SELECT.limit.offset ? parsed.SELECT.limit.offset.val : 0
    cqn.limit(Math.min(rows, getMaxPageSize(target)), offset)
  }

  if (!cds.env.features.rest_new_parser) {
    // REVISIT not needed for rest parser?
    rewriteAsterisk({ query: cqn, target })
  }

  return cqn
}

module.exports = { _newReadToCQN }
