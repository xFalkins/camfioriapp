const cds = require('../../cds')
let LOG = cds.log('app')
let _event

const getError = require('../error')

const _setInverseTransition = (mapping, ref, mapped) => {
  const existing = mapping.get(ref)
  if (!existing) mapping.set(ref, mapped)
  else {
    const alternatives = existing.alternatives || []
    alternatives.push(mapped)
    existing.alternatives = alternatives
    mapping.set(ref, existing)
  }
}

const _inverseTransition = transition => {
  const inverseTransition = {}
  inverseTransition.target = transition.queryTarget
  inverseTransition.queryTarget = transition.target
  inverseTransition.mapping = new Map()

  if (!transition.mapping.size) inverseTransition.mapping = new Map()

  for (const [key, value] of transition.mapping) {
    const mapped = {}
    if (value.ref) {
      if (value.transition) mapped.transition = _inverseTransition(value.transition)

      const ref0 = value.ref[0]
      if (value.ref.length > 1) {
        const nested = inverseTransition.mapping.get(ref0) || { transition: { mapping: new Map() } }
        let current = nested.transition.mapping
        for (let i = 1; i < value.ref.length; i++) {
          const last = i === value.ref.length - 1
          const obj = last ? { ref: [key] } : { transition: { mapping: new Map() } }
          _setInverseTransition(current, value.ref[i], obj)
          if (!last) current = current.get(value.ref[i]).transition.mapping
        }
        inverseTransition.mapping.set(ref0, nested)
      } else {
        mapped.ref = [key]
        _setInverseTransition(inverseTransition.mapping, ref0, mapped)
      }
    }
  }

  return inverseTransition
}

const revertData = (data, transition) => {
  if (!transition || !transition.mapping.size) return data
  const inverseTransition = _inverseTransition(transition)
  return Array.isArray(data)
    ? data.map(entry => _newData(entry, inverseTransition, true))
    : _newData(data, inverseTransition, true)
}

const _newSubData = (newData, key, transition, el, inverse) => {
  const val = newData[key]
  if ((!Array.isArray(val) && typeof val === 'object') || (Array.isArray(val) && val.length !== 0)) {
    let mapped = transition.mapping.get(key)
    if (!mapped) {
      mapped = {}
      transition.mapping.set(key, mapped)
    }
    if (!mapped.transition) {
      const subTransition = getTransition(el._target)
      mapped.transition = inverse ? _inverseTransition(subTransition) : subTransition
    }
    if (Array.isArray(val)) {
      newData[key] = val.map(singleVal => _newData(singleVal, mapped.transition, inverse))
    } else {
      newData[key] = _newData(val, mapped.transition, inverse)
    }
  }
}

const _newNestedData = (queryTarget, newData, ref, value) => {
  const parent = queryTarget.query && queryTarget.query._target
  let currentEntity = parent
  let currentData = newData
  for (let i = 0; i < ref.length; i++) {
    currentEntity = currentEntity.elements[ref[i]]
    if (currentEntity.isAssociation) {
      // > don't follow associations
      break
    } else {
      // > intermediate or final struct element
      if (i === ref.length - 1) currentData[ref[i]] = value
      else currentData = currentData[ref[i]] = currentData[ref[i]] || {}
    }
  }
}

const _newData = (data, transition, inverse) => {
  // no transition -> nothing to do
  if (transition.target && transition.target.name === transition.queryTarget.name) return data

  const newData = { ...data }
  const queryTarget = transition.queryTarget

  /*
   * REVISIT: the current impl results in {} instead of keeping null for compo to one.
   *          unfortunately, many follow-up errors occur (e.g., prop in null checks) if changed.
   */
  for (const key in newData) {
    const el = queryTarget && queryTarget.elements && queryTarget.elements[key]
    const isAssoc = el && el.isAssociation
    if (isAssoc) _newSubData(newData, key, transition, el, inverse)

    const mapped = transition.mapping.get(key)
    if (!mapped) {
      // if there is no mapping and no element with the same name in the target, then we don't need the data
      if (typeof newData[key] !== 'object' && !transition.target.elements[key]) delete newData[key]
      continue
    }

    if (!isAssoc && mapped.transition) {
      _newSubData(newData, key, transition, el, inverse)
      const value = newData[key]
      delete newData[key]
      Object.assign(newData, value)
    }

    if (mapped.ref) {
      const value = newData[key]
      delete newData[key]
      const { ref } = mapped
      if (ref.length === 1) {
        newData[ref[0]] = value
        if (mapped.alternatives) mapped.alternatives.forEach(({ ref }) => (newData[ref[0]] = value))
      } else {
        _newNestedData(queryTarget, newData, ref, value)
      }
    }
  }

  return newData
}

const _newColumns = (columns = [], transition, force = false, withAlias = false) => {
  const newColumns = []

  columns.forEach(column => {
    const mapped = column.ref && transition.mapping.get(column.ref[0])

    let newColumn
    if (mapped && mapped.ref) {
      newColumn = { ...column }

      if (withAlias) {
        newColumn.as = column.ref[column.ref.length - 1]
      }

      newColumn.ref = [...mapped.ref, ...column.ref.slice(mapped.ref.length)]
    } else if (mapped && mapped.val) {
      newColumn = {}
      newColumn.as = column.ref[0]
      newColumn.val = mapped.val
    } else {
      newColumn = column
    }

    // ensure that renaming of a redirected assoc are also respected
    if (column.expand) {
      // reuse _newColumns with new transition
      const expandTarget = transition.queryTarget.elements[column.ref[column.ref.length - 1]]._target
      const subtransition = getTransition(expandTarget, force)

      newColumn.expand = _newColumns(column.expand, subtransition, force, withAlias)
    }
    newColumns.push(newColumn)
  })

  return newColumns
}

const _newInsertColumns = (columns = [], transition) => {
  const newColumns = []

  columns.forEach(column => {
    const mapped = transition.mapping.get(column)
    if (mapped && mapped.ref) {
      newColumns.push(mapped.ref[0])
    } else if (!mapped) {
      newColumns.push(column)
    }
  })

  return newColumns
}

const _newEntries = (entries = [], transition) => entries.map(entry => _newData(entry, transition))

const _newWhere = (where = [], transition) => {
  const newWhere = []

  where.forEach(whereElement => {
    const mapped = whereElement.ref && transition.mapping.get(whereElement.ref[0])
    if (mapped && mapped.ref) {
      const newWhereElement = { ...whereElement }
      newWhereElement.ref = [...mapped.ref, ...newWhereElement.ref.slice(mapped.ref.length)]
      newWhere.push(newWhereElement)
    } else if (!mapped) {
      newWhere.push(whereElement)
    }
  })

  return newWhere
}

const _initialColumns = transition => {
  const columns = []

  for (const [transitionEl] of transition.mapping) {
    // REVISIT: structured elements
    if (!transition.queryTarget.elements[transitionEl] || transition.queryTarget.elements[transitionEl].isAssociation) {
      continue
    }
    columns.push({ ref: [transitionEl] })
  }

  return columns
}

const _rewriteQueryPath = (path, transitions) => {
  return path.ref.map((f, i) => {
    if (i === 0) {
      const target = transitions[0].target

      if (typeof f === 'string') {
        return target.name
      }

      if (f.id) {
        return {
          id: target.name,
          where: _newWhere(f.where, transitions[0])
        }
      }
    } else {
      if (typeof f === 'string') {
        const transitionMapping = transitions[i - 1].mapping.get(f)
        return (transitionMapping && transitionMapping.ref && transitionMapping.ref[0]) || f
      }

      if (f.id) {
        const transitionMapping = transitions[i - 1].mapping.get(f.id)
        return {
          id: (transitionMapping && transitionMapping.ref && transitionMapping.ref[0]) || f.id,
          where: _newWhere(f.where, transitions[i])
        }
      }
    }
  })
}

const _newUpdate = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newUpdate = { ...query.UPDATE }
  newUpdate.entity = newUpdate.entity.ref
    ? {
        ...newUpdate.entity,
        ref: _rewriteQueryPath(query.UPDATE.entity, transitions)
      }
    : targetName
  if (newUpdate.data) newUpdate.data = _newData(newUpdate.data, targetTransition)
  if (newUpdate.with) newUpdate.with = _newData(newUpdate.with, targetTransition)
  if (newUpdate.where) newUpdate.where = _newWhere(newUpdate.where, targetTransition)
  Object.defineProperty(newUpdate, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newUpdate
}

const _newSelect = (query, transitions, force) => {
  const targetTransition = transitions[transitions.length - 1]
  const newSelect = { ...query.SELECT }
  newSelect.from = {
    ...newSelect.from,
    ref: _rewriteQueryPath(query.SELECT.from, transitions)
  }
  if (!newSelect.columns && targetTransition.mapping.size) newSelect.columns = _initialColumns(targetTransition)
  if (newSelect.columns) newSelect.columns = _newColumns(newSelect.columns, targetTransition, force, true)
  if (newSelect.having) newSelect.having = _newColumns(newSelect.having, targetTransition)
  if (newSelect.groupBy) newSelect.groupBy = _newColumns(newSelect.groupBy, targetTransition)
  if (newSelect.orderBy) newSelect.orderBy = _newColumns(newSelect.orderBy, targetTransition)
  if (newSelect.where) newSelect.where = _newWhere(newSelect.where, targetTransition)
  Object.defineProperty(newSelect, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newSelect
}

const _newInsert = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newInsert = { ...query.INSERT }
  newInsert.into = newInsert.into.ref
    ? {
        ...newInsert.into,
        ref: _rewriteQueryPath(query.INSERT.into, transitions)
      }
    : targetName
  if (newInsert.columns) newInsert.columns = _newInsertColumns(newInsert.columns, targetTransition)
  if (newInsert.entries) newInsert.entries = _newEntries(newInsert.entries, targetTransition)
  Object.defineProperty(newInsert, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newInsert
}

const _newDelete = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newDelete = { ...query.DELETE }
  newDelete.from = newDelete.from.ref
    ? {
        ...newDelete.from,
        ref: _rewriteQueryPath(query.DELETE.from, transitions)
      }
    : targetName
  if (newDelete.where) newDelete.where = _newWhere(newDelete.where, targetTransition)
  Object.defineProperty(newDelete, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newDelete
}

const _isPersistenceTable = target => {
  const persistenceTableTerm = '@cds.persistence.table'
  const hasOwnProperty = Object.prototype.hasOwnProperty
  const isPersistenceTable = hasOwnProperty.call(target, persistenceTableTerm) && target[persistenceTableTerm]
  return isPersistenceTable
}

const _queryColumns = (target, force = false) => {
  const columns = (target && target.query && target.query.SELECT && target.query.SELECT.columns) || []
  if (force) return columns

  // If the entity is annotated with the annotation `@cds.persistence.table`
  // and elements aliases exist, the aliases must be used as column references.
  // The reason is that in this scenario, the cds compiler generate a table
  // instead of a view.
  if (_isPersistenceTable(target)) {
    return columns.map(column => {
      return { ref: [column.as || column.ref[0]] }
    })
  }

  return columns
}

// Find aliased column from the projection and set it as ref
const _renameColumns = (target, columns, force = false) => {
  const queryColumns = _queryColumns(target, force)

  const renamedColumns = columns.map(column => {
    const queryColumn =
      column.ref &&
      queryColumns.find(
        queryColumn =>
          ((queryColumn.ref && queryColumn.as && queryColumn.ref[queryColumn.ref.length - 1] !== queryColumn.as) ||
            queryColumn.val) &&
          column.ref[0] === queryColumn.as
      )

    if (queryColumn) {
      const renamedColumn = { as: column.ref[0] }
      if (column.as) renamedColumn.as = column.as
      if (queryColumn.ref) {
        const aliasOfTargetEntity = target.query.SELECT && target.query.SELECT.from && target.query.SELECT.from.as
        renamedColumn.ref =
          aliasOfTargetEntity && queryColumn.ref[0] === aliasOfTargetEntity ? queryColumn.ref.slice(1) : queryColumn.ref
      }
      if (queryColumn.val) renamedColumn.val = queryColumn.val
      return renamedColumn
    }

    return column
  })

  return renamedColumns
}

const _merge = (aliased, inherited) =>
  inherited.reduce(
    (res, el1) =>
      (!aliased.some(el2 => el2.ref && ((el1.as && el2.ref[0] === el1.as) || (el1.ref && el2.ref[0] === el1.ref[0]))) &&
        res.concat(el1)) ||
      res,
    []
  )

const _starColumns = elements => Object.keys(elements).map(element => ({ ref: [element] }))

const _mappedValue = (col, alias) => {
  const key = col.as || col.ref[0]

  if (col.ref) {
    const columnRef = col.ref.filter(columnName => columnName !== alias)
    return [key, { ref: columnRef }]
  }

  return [key, { val: col.val }]
}

// Don't check for table in case of external services (-> force)
// Reason for hasOwnProperty: All projections have target in their prototype
// Revisit: Check if this is really intended
const _isProjection = (target, force) => target.query && target.query._target && (force || !_isPersistenceTable(target))

const getDBTable = (target, force) => {
  if (_isProjection(target, force)) {
    return getDBTable(target.query._target, force)
  }
  return target
}

const _includeForeignKeys = (columns, target, force) => {
  for (const column of _queryColumns(target, force)) {
    const columnName = column.ref && column.ref[0]
    const el = column.as && target.elements && target.elements[column.as]
    if (columnName && el && el.name && el.type === 'cds.Association' && el.keys) {
      for (const rootKeys of el.keys) {
        // REVISIT: Check if this also works for deeply nested ones
        // .as and .ref has a different meaning here
        // .as means the original property name, if the foreign key is renamed
        const rootKeyName = rootKeys.as || (rootKeys.ref && rootKeys.ref[0])
        columns.push({
          ref: [`${columnName}_${rootKeyName}`],
          as: `${el.name}_${rootKeyName}`
        })
      }
    }
  }
}

const _checkForForbiddenViews = queryTarget => {
  const select = queryTarget && queryTarget.query && queryTarget.query.SELECT
  if (select) {
    if (!select.from || select.from.join || select.from.length > 1) {
      throw getError({
        code: 501,
        message: 'NON_WRITABLE_VIEW',
        target: queryTarget.name,
        args: [_event || 'INSERT|UPDATE|DELETE']
      })
    }
    if (select.where) {
      LOG._debug &&
        LOG.debug(`Ignoring where clause during ${_event || 'INSERT|UPDATE|DELETE'} on view "${queryTarget.name}".`)
    }
  }
}

const _filterColumnsOnce = (target, columns = [], force) => {
  if (columns.length > 0) return columns

  const cqnColumns = _queryColumns(target, force)

  const plainColumns = cqnColumns
    // There could be some `where` clause inside `ref` which we don't support yet
    .filter(c => c !== '*' && !(c.ref && c.ref.some(ele => typeof ele !== 'string')) && !c.xpr)
    .map(c => ({ ref: (c.as && [c.as]) || c.ref }))
  _includeForeignKeys(columns, target, force)

  const _target = target.query && target.query._target
  if (_target && cqnColumns.some(c => c === '*')) {
    // 'alias' is required to properly perform mapping
    const starColumns = _starColumns(_target.elements).map(c => (c.as && c) || { as: c.ref[0], ref: c.ref })
    columns.push(..._merge(plainColumns, starColumns))
  }

  columns.push(...plainColumns)

  return columns
}

const _getTransitionData = (target, columns, force, skipForbiddenViewCheck) => {
  // REVISIT: Find less param polluting way to skip forbidden view check for reads
  if (!skipForbiddenViewCheck) _checkForForbiddenViews(target)

  if (!columns.length) {
    columns = _filterColumnsOnce(target, columns, force)
  }

  if (_isProjection(target, force)) {
    columns = _renameColumns(target, columns, force)
    const newTarget = target.query._target
    return _getTransitionData(newTarget, columns, force, skipForbiddenViewCheck)
  }

  return { target, transitionColumns: columns }
}

/**
 * If no entity definition is found, no transition is done.
 *
 * @param queryTarget
 * @param force
 * @param skipForbiddenViewCheck
 */
const getTransition = (queryTarget, force, skipForbiddenViewCheck) => {
  // Never resolve unknown targets (e.g. for drafts)
  if (!queryTarget || (_isPersistenceTable(queryTarget) && !force)) {
    return { target: queryTarget, queryTarget, mapping: new Map() }
  }

  const { target: _target, transitionColumns } = _getTransitionData(queryTarget, [], force, skipForbiddenViewCheck)
  const query = queryTarget.query
  const alias = query && query.SELECT && query.SELECT.from && query.SELECT.from.as
  const mappedColumns = transitionColumns.map(column => _mappedValue(column, alias))
  const mapping = new Map(mappedColumns)
  return { target: _target, queryTarget, mapping }
}

const _entityTransitionsForTarget = (from, model, force) => {
  let previousEntity

  if (typeof from === 'string') {
    return model.definitions[from] && [getTransition(model.definitions[from], force)]
  }

  return from.ref.map((f, i) => {
    const element = f.id || f

    if (i === 0) {
      const entity = model.definitions[element]
      if (entity) {
        previousEntity = entity
        return getTransition(entity, force)
      }
    }

    if (previousEntity) {
      const entity = previousEntity.elements[element] && previousEntity.elements[element]._target

      if (entity) {
        previousEntity = entity
        return getTransition(entity, force)
      }
    }
  })
}

const _newQuery = (query, event, model, force) => {
  const [_prop, _func] = {
    SELECT: ['from', _newSelect],
    INSERT: ['into', _newInsert],
    UPDATE: ['entity', _newUpdate],
    DELETE: ['from', _newDelete]
  }[event]
  const newQuery = Object.create(query)
  const transitions = _entityTransitionsForTarget(query[event][_prop], model, force)
  newQuery[event] = (transitions[0] && _func(newQuery, transitions, force)) || { ...query[event] }
  return newQuery
}

const resolveView = (query, model, component, force) => {
  // swap logger
  const _LOG = LOG
  LOG = cds.log(component)

  // If the query is a projection, one must follow it
  // to let the underlying service know its true entity.

  if (query.SELECT) _event = 'SELECT'
  if (query.INSERT) _event = 'INSERT'
  if (query.UPDATE) _event = 'UPDATE'
  if (query.DELETE) _event = 'DELETE'

  const newQuery = _newQuery(query, _event, model, force)

  // restore logger and clear _event
  LOG = _LOG
  _event = undefined

  return newQuery
}

module.exports = {
  getDBTable,
  resolveView,
  getTransition,
  revertData
}
