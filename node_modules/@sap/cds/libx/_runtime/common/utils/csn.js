const cds = require('../../cds')

const { ensureNoDraftsSuffix } = require('./draft')

const getEtagElement = entity => {
  return Object.values(entity.elements).find(element => element['@odata.etag'])
}

const _isBacklink = (assoc, parent, target) => {
  const comps = Object.values(target.associations || {})
    .filter(assoc => assoc._isCompositionEffective)
    .filter(assoc => assoc.target === parent.name)
  if (comps.length === 0) return false

  let backlink = false
  for (const comp of comps) {
    const on = comp.on.find(ele => typeof ele === 'object' && ele.ref[0] !== '$self')
    if (on.ref.length === 2 && on.ref[on.ref.length - 1] === assoc.name) {
      backlink = true
      break
    }
  }
  return backlink
}

const _isDependent = (assoc, parent, target) => {
  return (
    assoc._isAssociationStrict &&
    assoc.is2one &&
    !assoc.on &&
    !parent['@cds.persistence.skip'] &&
    assoc['@assert.integrity'] !== false &&
    parent['@assert.integrity'] !== false &&
    (!parent._service || parent._service['@assert.integrity'] !== false) &&
    !_isBacklink(assoc, parent, target)
  )
}

/*
 * this modifies the csn on purpose for caching effect!
 * doing as aspect is difficult due to no global definitons per tenant
 */
const getDependents = (entity, model) => {
  if (entity._dependents !== undefined) return entity._dependents

  /** @type {Array|boolean} */
  let dependents = []
  for (const def of Object.values(model.definitions)) {
    if (def.kind !== 'entity') continue
    if (!def.associations) continue

    for (const assoc of Object.values(def.associations)) {
      if (assoc.target !== entity.name) continue

      const parent = assoc.parent
      const target = model.definitions[assoc.target]
      if (_isDependent(assoc, parent, target)) {
        dependents.push({ element: assoc, parent, target })
      }
    }
  }

  if (dependents.length === 0) dependents = false
  Object.defineProperty(entity, '_dependents', { value: dependents })
  return dependents
}

const _findRootEntity = (entities, edmName) => {
  const parts = edmName.split('_')
  let csnName = parts.shift()
  let target = entities[csnName]
  const len = parts.length
  // try to find a correct entity "greedy" and count leftovers (x4 case below)
  // e.g. we have 2 entities: 'C_root_' and dependant 'C_root_.kid_'
  // for 'C_root_.kid_assoc_prop' it should find 'C_root_.kid_'
  // and report 2 leftovers (namely 'assoc' and 'prop')
  let left = len
  let acc = 0
  for (let i = 0; i < len; i++) {
    /**
     * Calculate CSN name.
     * if target in entities connect with .
     * if target not in entities connect with _
     */
    csnName = `${csnName}${entities[csnName] ? '.' : '_'}${parts[i]}`
    ++acc
    if (entities[csnName]) {
      target = entities[csnName]
      left -= acc
      acc = 0
    }
  }
  // make sure we consider leftovers only for x4
  return { left: (cds.env.effective.odata.proxies && left) || 0, target: target }
}

const findCsnTargetFor = (edmName, model, namespace) => {
  const cache =
    model._edmToCSNNameMap || Object.defineProperty(model, '_edmToCSNNameMap', { value: {} })._edmToCSNNameMap
  const mapping =
    cache[namespace] ||
    Object.defineProperty(cache, namespace, { enumerable: true, configurable: true, value: {} })[namespace]

  if (mapping[edmName]) return mapping[edmName]

  const entities = model.entities(namespace)
  // simple cases
  let target = entities[edmName] || entities[edmName.replace(/_/g, '.')]
  if (!target) {
    // probably, a combination of '_' and '.', resolving
    const finding = _findRootEntity(entities, edmName)
    target = finding.target
    // something left in navigation path => x4 navigation
    // resolving within found entity
    if (target && finding.left > 0) {
      const left = edmName.split('_').slice(-finding.left)
      while (target && left.length) {
        let elm = left.shift()
        while (!target.elements[elm]) elm = `${elm}_${left.shift()}`
        target = target.elements[elm]
      }
    }
  }
  // remember edm <-> csn
  if (target) {
    mapping[edmName] = target
  }
  return mapping[edmName]
}

const isRootEntity = (definitions, entityName) => {
  const entity = definitions[entityName]
  if (!entity) return false

  // TODO: There can be unmanaged relations to some parent -> not detected by the following code
  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(element => element._isAssociationEffective)

  for (const { target } of associationElements) {
    const parentEntity = definitions[target]
    for (const parentElementName in parentEntity.elements) {
      const parentElement = parentEntity.elements[parentElementName]
      if (
        parentElement._isCompositionEffective &&
        parentElement.target === entityName &&
        !(parentElement.parent && ensureNoDraftsSuffix(parentElement.parent.name) === entityName)
      ) {
        return false
      }
    }
  }
  return true
}

module.exports = {
  getEtagElement,
  findCsnTargetFor,
  getDependents,
  isRootEntity
}
