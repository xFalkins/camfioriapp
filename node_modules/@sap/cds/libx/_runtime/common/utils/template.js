const _addSubTemplate = (templateElements, elementName, subTemplate) => {
  if (subTemplate.elements.size > 0) {
    const t = templateElements.get(elementName)
    if (t) t.template = subTemplate
    else templateElements.set(elementName, { template: subTemplate })
  }
}

const _addToTemplateElements = (templateElements, elementName, picked) => {
  const tEl = templateElements.get(elementName)
  if (tEl) Object.assign(tEl, { picked })
  else templateElements.set(elementName, { picked })
}

const _addCacheToTemplateElements = (templateElements, elementName, cached) => {
  const tEl = templateElements.get(elementName)
  if (tEl) tEl.template = cached.template
  else templateElements.set(elementName, cached)
}

const _pick = (pick, element, target, parent, templateElements, elementName) => {
  const _picked = pick(element, target, parent)
  if (_picked) _addToTemplateElements(templateElements, elementName, { plain: _picked })
}

const _isInlineStructured = element => {
  return (
    (element._isStructured && !element.type) || (element.items && element.items._isStructured && !element.items.type)
  )
}

const _isNextTargetCacheable = element => {
  return (
    element.isAssociation ||
    (element._isStructured && element.type) ||
    (element.items && element.items._isStructured && element.items.type)
  )
}

const _getNextTarget = (model, element, currentPath = []) => {
  // _typed_ targets have names whereas inlines are targets themselves
  // For inlines names should be resolved up to the entity to avoid struct name clashings in entityMap
  if (_isNextTargetCacheable(element)) {
    const nextTargetName = element.target || element.type || (element.items && element.items.type)
    return {
      nextTargetName,
      nextTarget: model.definitions[nextTargetName]
    }
  } else if (_isInlineStructured(element)) {
    return {
      nextTargetName: [...currentPath, element.name].join(' '),
      nextTarget: element.items || element
    }
  }
  return {}
}

/**
 *
 * @param {CSN} model: Model
 * @param {*} cache: Internal - do not use
 * @param {CSN} target: target entity which needs to be traversed
 * @param {*} param1.pick: Function to pick items. If it returns a truthy value, the item will be picked. The returned value is part of the template.
 * @param {*} param1.ignore: Function to ignore items. If it returns a truthy value, the item will be ignored.
 * @param {*} parent: The parent entity
 * @param {*} entityMap: Internal - do not use
 * @param model
 * @param targetName
 * @param parent
 * @param entityMap
 */
function _getTemplate(model, cache, target, { pick, ignore }, parent = null, entityMap = new Map(), targetPath = []) {
  const templateElements = new Map()
  const template = { target, elements: templateElements }
  const currentPath = [...targetPath, target.name]
  entityMap.set(currentPath.join(' '), { template })

  if (target.elements) {
    for (const elementName in target.elements) {
      const element = target.elements[elementName]
      if (ignore && ignore(element, target, parent)) continue

      _pick(pick, element, target, parent, templateElements, elementName)
      if (element.items) {
        _pick(pick, element.items, target, parent, templateElements, ['_itemsOf', elementName].join(' '))
      }

      const { nextTargetName, nextTarget } = _getNextTarget(model, element, currentPath)
      const nextTargetCached = entityMap.get(nextTargetName)
      if (nextTargetCached) {
        _addCacheToTemplateElements(templateElements, elementName, nextTargetCached)
      } else if (nextTarget) {
        // For associations and _typed_ structured elements, there's a (cacheable) target,
        // inline structures must be handled separately.
        const subTemplate = _isInlineStructured(element)
          ? _getTemplate(model, cache, nextTarget, { pick, ignore }, target, entityMap, currentPath)
          : cache.for(nextTarget, getTemplate(model, { pick, ignore }, target, entityMap))
        _addSubTemplate(templateElements, elementName, subTemplate)
      }
    }
  }

  return template
}

const getTemplate =
  (model, ...args) =>
  (target, cache) =>
    _getTemplate(model, cache, target, ...args)

const getCache = (anything, cache, newCacheFn) => {
  let _cached = cache.get(anything)
  if (!_cached) {
    _cached = (typeof newCacheFn === 'function' && newCacheFn(anything, cache)) || new Map()
    _cached.for = (_usecase, _newCacheFn) => getCache(_usecase, _cached, _newCacheFn)
    cache.set(anything, _cached)
  }
  return _cached
}

module.exports = (usecase, tx, target, ...args) => {
  // get model first as it may be added to tx (cf. "_ensureModel")
  const model = tx.model
  // double-check with get target from model
  // since target might come from anywhere like via cqn etc
  const root = target && model && model.definitions[target.name]
  // tx could be the service itself
  // prefer ApplicationService (i.e., tx.context._tx.__proto__)
  // REVISIT: context._tx is not a stable API -> pls do not rely on that
  const service = tx.context
    ? (tx.context._tx && Object.getPrototypeOf(tx.context._tx)) || Object.getPrototypeOf(tx)
    : tx
  if (!model || !service || !root) return
  // cache templates at service for garbage collection
  if (!service._templateCache) service._templateCache = new Map()
  // model can be also a subset from tx
  return getCache(usecase, service._templateCache)
    .for(model)
    .for(root, getTemplate(model, ...args))
}
