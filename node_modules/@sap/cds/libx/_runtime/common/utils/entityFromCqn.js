const { ensureNoDraftsSuffix } = require('../../common/utils/draft')

const _entityFromRef = ref => {
  if (ref) return ref[0].id || ref[0]
}

const getEntityNameFromCQN = cqn => {
  while (cqn.SELECT) {
    cqn = cqn.SELECT.from
  }

  return _getEntityNameFromUnionCQN(cqn) || _entityFromRef(cqn.ref)
}

const _getEntityNameFromUnionCQN = cqn => {
  // TODO cleanup
  // REVISIT infer should do this for req.target
  // REVISIT2 No, req.target doesn't make sense for joins
  if (cqn.SET) {
    return cqn.SET.args
      .map(arg => {
        return getEntityNameFromCQN(arg)
      })
      .filter(name => {
        return name !== 'DRAFT.DraftAdministrativeData'
      })[0]
  }
  if (cqn.join) {
    return cqn.args
      .map(arg => {
        return getEntityNameFromCQN(arg)
      })
      .filter(name => {
        return name !== 'DRAFT.DraftAdministrativeData'
      })[0]
  }
}

// Note: This also works for the common draft scenarios
const getEntityFromCQN = (req, service) => {
  if (!req.target || req.target._unresolved) {
    const entity = getEntityNameFromCQN(req.query)
    if (!entity) return
    return service.model.definitions[ensureNoDraftsSuffix(entity)]
  }
  return req.target
}

module.exports = {
  getEntityFromCQN,
  getEntityNameFromCQN
}
