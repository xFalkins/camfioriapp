const cds = require('../../cds')

const _generateParentField = (foreignKeyPropagations, row) => {
  if (
    foreignKeyPropagations.parentFieldName &&
    !row[foreignKeyPropagations.parentFieldName] &&
    foreignKeyPropagations.autoGenerate
  ) {
    row[foreignKeyPropagations.parentFieldName] = cds.utils.uuid()
  }
}

const _generateChildField = (foreignKeyPropagations, childRow) => {
  if (foreignKeyPropagations.deep) {
    const deep = foreignKeyPropagations.deep
    _generateChildField(deep.propagation, childRow[deep.targetName])
  } else if (childRow && !childRow[foreignKeyPropagations.childFieldName] && foreignKeyPropagations.autoGenerate) {
    childRow[foreignKeyPropagations.childFieldName] = cds.utils.uuid()
  }
}

const _getNestedVal = (row, prefix) => {
  let val = row
  const splitted = prefix.split('_')
  let k = ''
  while (splitted.length > 0) {
    k += splitted.shift()
    if (k in val) {
      val = val[k]
      k = ''
    } else {
      k += '_'
    }
  }
  return val
}

const _propagateToChid = (foreignKeyPropagation, row, childRow) => {
  const { parentFieldName, childFieldName, prefix, parentFieldValue } = foreignKeyPropagation
  if (parentFieldName) {
    if (prefix) {
      const nested = _getNestedVal(row, prefix)
      childRow[childFieldName] = nested[parentFieldName]
    } else {
      childRow[childFieldName] = row[parentFieldName]
    }
  } else if (parentFieldValue !== undefined) {
    childRow[childFieldName] = parentFieldValue
  }
}

const _propagateToParent = (foreignKeyPropagations, childRow, row) => {
  if (foreignKeyPropagations.deep) {
    const deep = foreignKeyPropagations.deep
    _propagateToParent(deep.propagation, childRow[deep.targetName], childRow)
  }
  if (childRow && Object.prototype.hasOwnProperty.call(childRow, foreignKeyPropagations.childFieldName))
    row[foreignKeyPropagations.parentFieldName] = childRow[foreignKeyPropagations.childFieldName]
}

const propagateForeignKeys = (tKey, row, foreignKeyPropagations) => {
  const childRows = Array.isArray(row[tKey]) ? row[tKey] : [row[tKey]]
  for (const childRow of childRows) {
    if (!childRow) return
    for (const foreignKeyPropagation of foreignKeyPropagations) {
      if (foreignKeyPropagation.fillChild) {
        _generateParentField(foreignKeyPropagation, row)
        _propagateToChid(foreignKeyPropagation, row, childRow)
      } else {
        _generateChildField(foreignKeyPropagation, childRow)
        _propagateToParent(foreignKeyPropagation, childRow, row)
      }
    }
  }
}

const _getSubOns = on => {
  // this only works for on conds with `and`, once we support `or` this needs to be adjusted
  const newOn = on.filter(e => e !== '(' && e !== ')')
  const subOns = []
  let currArr = []
  for (const onEl of newOn) {
    if (currArr.length === 0) subOns.push(currArr)
    if (onEl !== 'and') currArr.push(onEl)
    else {
      currArr = []
    }
  }
  for (const subOn of subOns) {
    // We don't support anything else than
    // A = B AND C = D AND ...
    if (subOn.length !== 3) return []
  }
  return subOns
}

const _autoGenerate = el => el && el.type === 'cds.UUID' && el.key

const _parentFieldsFromSimpleOnCond = (element, subOn) => {
  const idxChildField = subOn.findIndex(o => o.ref && o.ref[0] === element.name)
  if (idxChildField === -1 || subOn[1] !== '=') return
  const childFieldName = subOn[idxChildField].ref && subOn[idxChildField].ref.slice(1).join('_')
  const childElement = element._target.elements[childFieldName]
  const idxParentField = idxChildField === 2 ? 0 : 2
  let parentRef = Array.isArray(subOn[idxParentField].ref) && [...subOn[idxParentField].ref]

  if (parentRef && parentRef.length > 1) {
    const idxChildInParent = parentRef.findIndex(e => e === element.name)
    if (idxChildInParent > -1) parentRef.splice(idxChildInParent, 1)
    parentRef = [parentRef.join('_')]
  }

  if (!childElement) {
    // update on view with key in parent

    return [
      {
        fillChild: false,
        childFieldName,
        parentFieldName: parentRef[0],
        autoGenerate: _autoGenerate(element.parent.elements[parentRef[0]])
      }
    ]
  }

  if (!childElement.on && parentRef && parentRef.length === 1) {
    return _foreignKeyPropagationsFromToManyOn(element, parentRef, childFieldName)
  }
  if ('val' in subOn[idxParentField]) {
    return _foreignKeyPropagationsFromStaticOn(childFieldName, idxParentField, subOn)
  }
  if (childElement._isAssociationStrict && childElement.on) {
    return _foreignKeyPropagationsFromCustomBacklink(element, childElement)
  }
}

const _foreignKeyPropagationsFromStaticOn = (childFieldName, idxParentField, subOn) => {
  if (childFieldName) {
    return [{ fillChild: true, parentFieldValue: subOn[idxParentField].val, childFieldName }]
  }
}

const _foreignKeyPropagationsFromToManyOn = (element, parentRef, childFieldName) => {
  const parentFieldName = parentRef[0]
  if (parentFieldName === '$self') {
    const foreignKeys = _foreignKeysForTarget(element, childFieldName)
    // REVISIT foreignKeys is empty if we have deep operations where a sub element is annotated with persistence skip
    if (foreignKeys && foreignKeys.length) {
      const parentKeys = _parentKeys(element)

      return resolvedKeys(parentKeys, foreignKeys, true)
    }

    return []
  }

  return [
    {
      fillChild: true,
      childFieldName,
      parentFieldName,
      autoGenerate: _autoGenerate(element.parent.elements[parentFieldName])
    }
  ]
}

const _foreignKeyPropagationsFromCustomBacklink = (element, childElement) => {
  const foreignKeyPropagations = []
  const subOns = _getSubOns(childElement.on)
  for (const subOn of subOns) {
    if (subOn[1] === '=') {
      const parentFieldIdx = subOn.findIndex(o => o.ref && o.ref[0] === childElement.name)
      const otherFieldIdx = parentFieldIdx === 0 ? 2 : 0
      const otherField = subOn[otherFieldIdx]
      if (otherField.ref && otherField.ref.length === 1) {
        const parentFieldName = subOn[parentFieldIdx].ref[1]
        foreignKeyPropagations.push({
          fillChild: true,
          parentFieldName,
          childFieldName: otherField.ref[0],
          autoGenerate: _autoGenerate(element.parent.elements[parentFieldName])
        })
      } else if (otherField.val !== undefined) {
        const parentFieldName = subOn[parentFieldIdx] && subOn[parentFieldIdx].ref[1]
        const parentField = subOn[otherFieldIdx === 2 ? 0 : 2]
        foreignKeyPropagations.push({
          fillChild: true,
          parentFieldName,
          parentFieldValue: parentField.val,
          childFieldValue: otherField.val
        })
      }
    }
  }
  return foreignKeyPropagations
}

const _foreignKeyPropagationsFromOn = (element, on) => {
  const subOns = _getSubOns(on)

  const foreignKeyPropagations = []
  for (const subOn of subOns) {
    const subParentFields = _parentFieldsFromSimpleOnCond(element, subOn)
    if (subParentFields) foreignKeyPropagations.push(...subParentFields)
  }
  return foreignKeyPropagations
}

/*
 * recursive resolvedKeys for a structured element
 * returns how many indexes can be skipped in the outer loop
 * example:
 *   foo: {
 *     bar: {
 *       moo: Integer;
 *       shu: Integer;
 *     };
 *     baz: Integer;
 *   };
 *   -> foo_bar_moo, foo_bar_shu, foo_baz
 *   -> processed three instead of one from outer loop perspective
 */
const _resolve4struct = (others, struct, fkps, fillChild, childIsStruct, i) => {
  let j = 0

  for (const k in struct.elements) {
    const other = others[i + j]
    const current = struct.elements[k]
    if (current._isStructured) {
      // call recursive and increment skip
      j += _resolve4struct(others, current, fkps, fillChild, childIsStruct, i + j)
    } else if (current.isAssociation) {
      continue
    } else {
      // calc prefix
      let prefix = struct.name
      let cur = struct.parent
      while (cur._isStructured) {
        prefix = cur.name + '_' + prefix
        cur = cur.parent
      }
      // push propagation
      fkps.push({
        childFieldName: childIsStruct ? current.name : other.name,
        parentFieldName: childIsStruct ? other.name : current.name,
        fillChild,
        autoGenerate: _autoGenerate(other),
        prefix,
        deep: !fillChild && _resolveTargetForeignKey(childIsStruct ? current : other)
      })
      // increment skip
      j++
    }
  }

  return j
}

const _resolveTargetForeignKey = targetKey => {
  const targetName = targetKey['@odata.foreignKey4']
  if (!targetName) return
  const _foreignKeyPropagations = foreignKeyPropagations(targetKey.parent.elements[targetName])
  const propagation = _foreignKeyPropagations.find(_fkp => targetKey.name === _fkp.parentFieldName)
  return { targetName, propagation }
}

const resolvedKeys = (foreignKeys, targetKeys, fillChild) => {
  const foreignKeyPropagations = []

  for (let i = 0; i < foreignKeys.length; i++) {
    const fk = foreignKeys[i]
    const tk = targetKeys[i]
    if (fk._isStructured) {
      i += _resolve4struct(targetKeys, fk, foreignKeyPropagations, fillChild, false, i)
    } else if (tk._isStructured) {
      i += _resolve4struct(foreignKeys, tk, foreignKeyPropagations, fillChild, true, i)
    } else {
      foreignKeyPropagations.push({
        fillChild,
        childFieldName: tk.name,
        autoGenerate: _autoGenerate(tk),
        parentFieldName: fk.name,
        // needed only for child -> parent propagation since template loops in other direction
        deep: !fillChild && _resolveTargetForeignKey(tk)
      })
    }
  }

  return foreignKeyPropagations
}

const foreignKeyPropagations = element => {
  if (element.is2many && element.on) {
    return _foreignKeyPropagationsFromOn(element, element.on)
  }

  if (element.is2one) {
    if (!element.on) {
      const foreignKeys = _foreignKeys(element)
      if (foreignKeys) {
        const targetKeys = _targetKeys(element)
        return resolvedKeys(foreignKeys, targetKeys)
      }

      return []
    } else {
      // It's a link through a backlink
      return _foreignKeyPropagationsFromOn(element, element.on)
    }
  }
}

const _foreignKeys = csnElement => {
  return Object.values(csnElement.parent.elements).filter(element => element['@odata.foreignKey4'] === csnElement.name)
}

const _foreignKeysForTarget = (csnElement, name) => {
  return Object.values(csnElement._target.elements).filter(
    element =>
      !element.isAssociation && !element.isComposition && element['@odata.foreignKey4'] === (name || csnElement.name)
  )
}

const _targetKeys = csnElement => {
  return Object.values(csnElement._target.keys).filter(
    element => !element.isAssociation && !element.isComposition && element.name !== 'IsActiveEntity'
  )
}

const _parentKeys = csnElement => {
  return Object.values(csnElement.parent.keys).filter(
    element => !element.isAssociation && !element.isComposition && element.name !== 'IsActiveEntity'
  )
}

const _structPrefix = csnElement => {
  if (csnElement.parent && csnElement.parent._isStructured) {
    const prefix = _structPrefix(csnElement.parent)
    if (!prefix) return csnElement.parent.name + '_'
    return prefix + csnElement.parent.name + '_'
  }

  return ''
}

module.exports = {
  foreignKeyPropagations,
  propagateForeignKeys,
  _foreignKeys,
  _targetKeys,
  _structPrefix
}
