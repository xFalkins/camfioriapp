const { getCompositionTree } = require('./tree')
const ctUtils = require('./utils')

const { ensureNoDraftsSuffix } = require('../utils/draft')
const { getDBTable } = require('../utils/resolveView')
const cqn2cqn4sql = require('../utils/cqn2cqn4sql')
const cds = require('../../cds')

/*
 * own utils
 */

const _isSameEntity = (cqn, req) => {
  const where = cqn.UPDATE.where || []
  const persistentObj = Array.isArray(req._.partialPersistentState)
    ? req._.partialPersistentState[0]
    : req._.partialPersistentState
  if (!persistentObj) {
    // If no data was found we don't know if it is the same entity
    return false
  }
  const target = getDBTable(req.target)
  if (target.name !== (cqn.UPDATE.entity.ref && cqn.UPDATE.entity.ref[0]) && target.name !== cqn.UPDATE.entity) {
    return false
  }
  for (let i = 0; i < where.length; i++) {
    if (!where[i] || !where[i].ref || !target.elements[where[i].ref]) {
      continue
    }
    const key = where[i].ref
    const val = where[i + 2].val
    const sign = where[i + 1]
    // eslint-disable-next-line
    if (target.elements[key].key && key in persistentObj && sign === '=' && val !== persistentObj[key]) {
      return false
    }
  }
  return true
}

const _from = query =>
  (query.UPDATE.entity.ref && query.UPDATE.entity.ref[0]) || query.UPDATE.entity.name || query.UPDATE.entity

const _getLinksOfCompTree = compositionTree => {
  const links = []
  for (const compElement of compositionTree.compositionElements || []) {
    for (const link of compElement.links || []) {
      links.push(link.entityKey)
    }
  }
  return links
}

const _dataElements = entity => {
  // REVISIT: this is expensive
  return Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(e => !e.virtual && !e.isAssociation)
}

const _whereKeys = keys => {
  const where = []
  keys.forEach(key => {
    if (where.length > 0) {
      where.push('or')
    }
    where.push('(', ...ctUtils.whereKey(key), ')')
  })
  return where
}

const _parentKey = (element, key) => {
  const parentKey = {}

  element.customBackLinks.reduce((parentKey, customBackLink) => {
    parentKey[customBackLink.entityKey] = key[customBackLink.targetKey] || customBackLink.targetVal
    return parentKey
  }, parentKey)

  return element.backLinks.reduce((parentKey, backlink) => {
    parentKey[backlink.entityKey] = key[backlink.targetKey] || backlink.targetVal
    return parentKey
  }, parentKey)
}

const _findWhere = (data, where) => {
  return data.filter(entry => {
    return Object.keys(where).every(key => {
      return where[key] === entry[key]
    })
  })
}

const _keys = (entity, data) => {
  return data.map(entry => {
    return ctUtils.key(entity, entry)
  })
}

const _parentKeys = (element, keys) => {
  return keys.map(key => {
    return _parentKey(element, key)
  })
}

const _subData = (data, prop) =>
  data &&
  data.reduce((result, entry) => {
    if (prop in entry) {
      const elementValue = ctUtils.val(entry[prop])
      result.push(...ctUtils.array(elementValue))
    }
    return result
  }, [])

const _subWhere = (result, links) => {
  let where
  if (links && links.length > 0) {
    where = []
    for (const row of result) {
      if (where.length > 0) {
        where.push('or')
      }
      const whereObj = links.reduce((res, currentLink) => {
        res[currentLink.targetKey] = row[currentLink.entityKey]
        return res
      }, {})
      where.push('(', ...ctUtils.whereKey(whereObj), ')')
    }
  }
  return where
}

const _mergeResults = (result, selectData, root, definitions, compositionTree, entityName) => {
  if (root) {
    return [...selectData, ...result]
  } else {
    const parent = definitions[compositionTree.target] || definitions[entityName]
    const assoc = (parent && parent.elements[compositionTree.name]) || {}
    return selectData.map(selectEntry => {
      if (assoc.is2one) {
        selectEntry[compositionTree.name] = selectEntry[compositionTree.name] || {}
      } else if (assoc.is2many) {
        selectEntry[compositionTree.name] = selectEntry[compositionTree.name] || []
      }
      let pk = _parentKey(compositionTree, selectEntry)
      // adjust pk for nested composition of one
      if (
        (!pk || Object.keys(pk).length === 0) &&
        assoc.isComposition &&
        assoc.is2one &&
        compositionTree.links.length === 1
      ) {
        pk = { [compositionTree.links[0].targetKey]: selectEntry[compositionTree.links[0].entityKey] }
      }
      const newData = _findWhere(result, pk)
      if (assoc.is2one && newData[0]) {
        selectEntry[compositionTree.name] = Object.assign(selectEntry[compositionTree.name], newData[0])
      } else if (assoc.is2many) {
        selectEntry[compositionTree.name].push(...newData)
      }
      return selectEntry
    })
  }
}

const _columns = (entity, data, compositionTree, selectAll) => {
  const links = _getLinksOfCompTree(compositionTree)
  const backLinkKeys = [
    ...compositionTree.backLinks.map(backLink => backLink.entityKey),
    ...compositionTree.customBackLinks.map(customBackLink => customBackLink.entityKey)
  ]
  const columns = _dataElements(entity)
    .filter(
      element =>
        selectAll ||
        element.key ||
        links.includes(element.name) ||
        backLinkKeys.includes(element.name) ||
        (Array.isArray(data) && data.find(entry => element.name in entry))
    )
    .map(element => {
      return { ref: [element.name] }
    })
  return columns
}

const _select = ({
  definitions,
  entityName,
  draft,
  alias,
  compositionTree,
  data,
  root,
  includeAllRootColumns,
  includeAllColumns,
  where,
  parentKeys,
  orderBy,
  singleton
}) => {
  const entity = definitions && definitions[entityName]
  const from = ctUtils.addDraftSuffix(draft, entity.name)
  const selectCQN = { SELECT: { from: { ref: [from] } } }
  if (alias) selectCQN.SELECT.from.as = alias
  const selectAll = includeAllColumns || (includeAllRootColumns && root)
  selectCQN.SELECT.columns = _columns(entity, data, compositionTree, selectAll)
  if (where) selectCQN.SELECT.where = where
  else if (parentKeys) selectCQN.SELECT.where = _whereKeys(parentKeys)
  if (orderBy) selectCQN.SELECT.orderBy = orderBy
  if (singleton) selectCQN.SELECT.limit = { rows: { val: 1 } }
  // REVISIT: remove once SELECT builder does flattening!
  return cqn2cqn4sql(selectCQN, { definitions })
}

const _selectDeepUpdateData = async args => {
  const { definitions, compositionTree, entityName, data, includeAllColumns, root, selectData, tx } = args
  const selectCQN = _select(args)
  const result = await tx.run(selectCQN)
  if (!result.length) return Promise.resolve(result)

  const keys = _keys(definitions[entityName], result)
  await Promise.all(
    compositionTree.compositionElements.map(element => {
      if (element.skipPersistence) return Promise.resolve()
      if (data !== undefined && !data.find(entry => element.name in entry) && !(includeAllColumns && result.length))
        return Promise.resolve()
      const subs = {
        compositionTree: element,
        entityName: element.source,
        data: _subData(data, element.name),
        where: _subWhere(result, element.links),
        selectData: result,
        parentKeys: _parentKeys(element, keys),
        orderBy: false,
        root: false
      }
      return _selectDeepUpdateData({ ...args, ...subs })
    })
  )

  return _mergeResults(result, selectData || [], root, definitions, compositionTree, entityName)
}

/*
 * exports
 */

const selectDeepUpdateData = (definitions, cqn, req, includeAllRootColumns = false) => {
  // REVISIT this should be done somewhere before, so it is not done twice for deep updates
  const sqlQuery = cqn2cqn4sql(cqn, { definitions })

  if (req && _isSameEntity(sqlQuery, req)) {
    return Promise.resolve(req._.partialPersistentState)
  }

  const from = _from(sqlQuery)
  const alias = sqlQuery.UPDATE.entity.as
  const where = sqlQuery.UPDATE.where || []
  const entityName = ensureNoDraftsSuffix(from)
  const draft = entityName !== from
  const orderBy = req && req.target && req.target.query && req.target.query.SELECT && req.target.query.SELECT.orderBy
  const data = Object.assign({}, sqlQuery.UPDATE.data || {}, cqn.UPDATE.with || {})
  const compositionTree = getCompositionTree({
    definitions,
    rootEntityName: entityName, // REVISIT: drafts are resolved too eagerly
    checkRoot: false,
    resolveViews: !draft
  })

  return _selectDeepUpdateData({
    tx: cds.tx(req),
    definitions,
    compositionTree,
    entityName,
    data: [data],
    where,
    orderBy,
    draft,
    includeAllRootColumns,
    singleton: req && req.target && req.target._isSingleton,
    alias,
    includeAllColumns: cqn._selectAll,
    root: true
  })
}

module.exports = {
  selectDeepUpdateData
}
