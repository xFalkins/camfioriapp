const cds = require('../../cds')

const { getCompositionTree } = require('./tree')
const ctUtils = require('./utils')

const { ensureNoDraftsSuffix } = require('../utils/draft')
const { getEntityNameFromDeleteCQN } = require('../utils/cqn')

/*
 * own utils
 */

// Poor man's alias algorithm
// REVISIT: Extract and adapt the alias functionality from `expandCQNToJoin.js`: _adaptWhereOrderBy
const _recursivelyAliasRefs = (something, newAlias, oldAlias, subselect = false) => {
  if (Array.isArray(something)) {
    for (const s of something) _recursivelyAliasRefs(s, newAlias, oldAlias, subselect)
  } else if (typeof something === 'object') {
    if (Array.isArray(something.ref)) {
      if (oldAlias && something.ref[0] === oldAlias) something.ref[0] = newAlias
      else if (!subselect) something.ref.unshift(newAlias)
    } else {
      for (const key in something)
        _recursivelyAliasRefs(something[key], newAlias, oldAlias, subselect || key === 'SELECT')
    }
  }
}

function _getSubWhereAndEntities(allBackLinks, links, draft, element, level) {
  let entity1, entity2
  const isBackLink = allBackLinks.length > 0
  const linksForWhere = isBackLink ? allBackLinks : links

  const subWhere = linksForWhere.reduce((result, backLink) => {
    // exclude static values from subwhere
    if (backLink.entityKey && !backLink.targetKey && backLink.targetVal !== undefined) {
      return result
    }
    if (result.length > 0) {
      result.push('and')
    }

    entity1 = {
      alias: `ALIAS${level + 1}`,
      entityName: ctUtils.addDraftSuffix(draft, element.source),
      propertyName: isBackLink ? backLink.entityKey : backLink.targetKey
    }

    const res1 = backLink.entityKey
      ? { ref: [entity1.alias, entity1.propertyName] }
      : { val: isBackLink ? backLink.entityVal : backLink.targetVal }

    entity2 = {
      alias: `ALIAS${level}`,
      entityName: ctUtils.addDraftSuffix(draft, element.target || element.source),
      propertyName: isBackLink ? backLink.targetKey : backLink.entityKey
    }

    const res2 = backLink.targetKey
      ? { ref: [entity2.alias, entity2.propertyName] }
      : { val: isBackLink ? backLink.targetVal : backLink.entityVal }

    result.push(res1, '=', res2)
    return result
  }, [])

  return {
    subWhere,
    entity1,
    entity2
  }
}

function _getWhereKeys(allBackLinks, entity1, is) {
  return allBackLinks.reduce((result, backLink) => {
    // exclude static keys
    if (backLink.entityKey && !backLink.targetKey && backLink.targetVal !== undefined) {
      return result
    }
    if (result.length > 0) {
      result.push('or')
    }
    if (backLink.entityKey && is) {
      result.push({ ref: [entity1.alias, backLink.entityKey] }, 'is ' + is)
    } else if (backLink.entityVal !== undefined) {
      // static values should not be included
      result.pop()
    }
    return result
  }, [])
}

function _getStaticWhere(allBackLinks, entity1) {
  return allBackLinks.reduce((result, backLink) => {
    if (result.length > 0) {
      result.push('and')
    }
    if (backLink.entityKey && !backLink.targetKey && backLink.targetVal !== undefined) {
      result.push({ ref: [entity1.alias, backLink.entityKey] }, '=', { val: backLink.targetVal })
    }
    return result
  }, [])
}

const _csnElementFromTarget = (element, definitions) =>
  element.target && definitions[element.target].elements[element.name]

const _is2OneManaged = element => {
  return element.is2one && ctUtils.isManaged(element)
}

const _addToCQNs = (cqns, subCQN, element, definitions, level) => {
  if (cds.env.features._foreign_key_constraints) {
    // deep delete should be handled by database constraints
    // return [[cqn]]
    const csnElement = _csnElementFromTarget(element, definitions)

    // TODO: only managed to-one should be filtered, unmanaged with key in children can be ignored
    if (csnElement && _is2OneManaged(csnElement)) {
      cqns[level] = cqns[level] || []
      cqns[level].push(subCQN)
    }
  } else {
    cqns[level] = cqns[level] || []
    cqns[level].push(subCQN)
  }
}

const _addSubCascadeDeleteCQN = (
  definitions,
  compositionTree,
  parentWhere,
  level,
  cqns,
  draft,
  elementSet = new Set()
) => {
  for (const element of compositionTree.compositionElements) {
    if (element.skipPersistence) continue

    const fqn = compositionTree.source + ':' + element.name
    if (elementSet.has(fqn)) {
      // recursion -> abort
      continue
    }

    // REVISIT: sometimes element.target is undefined which leads to self join
    if (!element.target) element.target = compositionTree.source

    const allBackLinks = [...element.backLinks, ...element.customBackLinks]
    const { entity1, entity2, subWhere } = _getSubWhereAndEntities(allBackLinks, element.links, draft, element, level)

    let whereKeys = _getWhereKeys(allBackLinks, entity1)
    const staticWhereValues = _getStaticWhere(allBackLinks, entity1)
    if (allBackLinks.length > 0 || element.links.length > 0) {
      const where = []

      if (whereKeys.length === 0 && element.links.length === 1) {
        // add is null check for each unused backlink
        for (const ce of compositionTree.compositionElements) {
          if (ce.source !== element.source) continue
          if (ce.name === element.name) continue
          const wk = _getWhereKeys([...ce.backLinks, ...ce.customBackLinks], entity1, 'null')
          if (whereKeys.length === 0) whereKeys = wk
          else whereKeys.push('and', ...wk)
        }
      }

      if (whereKeys.length > 0) {
        where.push('(', ...whereKeys, ')', 'and')
      }
      if (staticWhereValues.length > 0) {
        where.push('(', ...staticWhereValues, ')', 'and')
      }

      where.push('exists', {
        SELECT: {
          columns: [{ val: 1, as: '_exists' }],
          from: { ref: [entity2.entityName], as: entity2.alias },
          where: parentWhere ? ['(', ...parentWhere, ')', 'and', '(', ...subWhere, ')'] : subWhere
        }
      })

      const subCQN = { DELETE: { from: { ref: [entity1.entityName], as: entity1.alias }, where: where } }

      _addToCQNs(cqns, subCQN, element, definitions, level)

      elementSet.add(fqn)

      _addSubCascadeDeleteCQN(definitions, element, subCQN.DELETE.where, level + 1, cqns, draft, elementSet)
    }
  }

  return cqns
}

/*
 * exports
 */

const hasDeepDelete = (definitions, cqn) => {
  const from = getEntityNameFromDeleteCQN(cqn)
  if (!from) return false

  const entity = definitions && definitions[ensureNoDraftsSuffix(from)]
  if (entity) return !!Object.keys(entity.elements || {}).find(k => entity.elements[k]._isCompositionEffective)

  return false
}

const getDeepDeleteCQNs = (definitions, cqn) => {
  const from = getEntityNameFromDeleteCQN(cqn)
  if (!from) return [[cqn]]

  const entityName = ensureNoDraftsSuffix(from)
  // REVISIT: baaad check!
  const draft = entityName !== from
  const compositionTree = getCompositionTree({
    definitions,
    rootEntityName: entityName,
    checkRoot: false,
    resolveViews: !draft
  })
  const parentWhere = cqn.DELETE.where && JSON.parse(JSON.stringify(cqn.DELETE.where))
  if (parentWhere) {
    const parentAlias = cqn.DELETE.from.as || (cqn.DELETE.from.ref && cqn.DELETE.from.ref[0]) || cqn.DELETE.from // or however we get the table name...
    _recursivelyAliasRefs(parentWhere, 'ALIAS0', parentAlias)
  }

  return [[cqn], ..._addSubCascadeDeleteCQN(definitions, compositionTree, parentWhere, 0, [], draft)].reverse()
}

module.exports = {
  hasDeepDelete,
  getDeepDeleteCQNs
}
