const { isSelfManaged } = require('../utils/backlinks')

const { ensureNoDraftsSuffix, ensureDraftsSuffix } = require('../utils/draft')

const addDraftSuffix = (draft, name) => {
  return draft ? ensureDraftsSuffix(name) : ensureNoDraftsSuffix(name)
}

const whereKey = key => {
  const where = []
  Object.keys(key).forEach(keyPart => {
    if (where.length > 0) {
      where.push('and')
    }
    where.push({ ref: [keyPart] }, '=', { val: key[keyPart] })
  })
  return where
}

const keyElements = entity => {
  // REVISIT: this is expensive
  return Object.keys(entity.keys)
    .map(key => entity.keys[key])
    .filter(e => !e.virtual && !e.isAssociation)
}

const key = (entity, data) => {
  return keyElements(entity).reduce((result, element) => {
    result[element.name] = data[element.name]
    return result
  }, {})
}

const val = element => (element && element.val) || element

const array = x => (Array.isArray(x) ? x : [x])

const isManaged = element => {
  return isSelfManaged(element) || !element.on
}

const isCompOrAssoc = (entity, k, onlyToOne) => {
  return (
    entity.elements &&
    entity.elements[k] &&
    entity.elements[k].isAssociation &&
    ((onlyToOne && entity.elements[k].is2one) || !onlyToOne)
  )
}

const cleanDeepData = (entity, data, onlyToOne = false) => {
  if (!Array.isArray(data)) {
    return cleanDeepData(entity, [data], onlyToOne)[0]
  }
  return data.map(entry => {
    return Object.keys(entry || {}).reduce((result, k) => {
      if (!isCompOrAssoc(entity, k, onlyToOne)) {
        result[k] = entry[k]
      }
      return result
    }, {})
  })
}

module.exports = {
  addDraftSuffix,
  whereKey,
  keyElements,
  key,
  val,
  array,
  isManaged,
  isCompOrAssoc,
  cleanDeepData
}
