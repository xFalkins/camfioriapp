const cds = require('../../cds')

const { getBackLinks, isSelfManaged, getOnCondElements, isBacklink } = require('../utils/backlinks')
const ctUtils = require('./utils')

const { ensureNoDraftsSuffix } = require('../utils/draft')
const { isRootEntity } = require('../utils/csn')
const { getTransition, getDBTable } = require('../utils/resolveView')

const getError = require('../../common/error')

/*
 * own utils
 */

const _resolvedElement = element => {
  if (!element.target) return element
  // skip forbidden view check if association to view with foreign key in target
  const skipForbiddenViewCheck = element._isAssociationStrict && element.on && !element['@odata.contained']
  const { target, mapping } = getTransition(element._target, undefined, skipForbiddenViewCheck)
  const newElement = { target: target.name, _target: target }
  Object.setPrototypeOf(newElement, element)
  if (element.on) {
    newElement.on = element.on.map(onEl => {
      if (!onEl.ref || onEl.ref[0] !== element.name) return onEl
      const mapped = mapping.get(onEl.ref[1])
      if (!mapped || !mapped.ref) return onEl
      const newRef = [onEl.ref[0], mapped.ref[0]]
      return { ...onEl, ...{ ref: newRef } }
    })
  }
  return newElement
}

const _navigationExistsInCompositionMap = (element, compositionMap) =>
  compositionMap.has(element.target) && element._isCompositionEffective

const _addNavigationToCompositionElements = (element, definitions, compositionTree, compositionMap, isManaged) => {
  const links = element.is2one ? getBackLinks(element) : []

  const compositionElement = Object.assign({}, compositionMap.get(element.target), { name: element.name, links })
  compositionElement.target = element.parent.name
  const backLinks = element.is2many ? getBackLinks(element) : []

  if (isManaged) {
    compositionElement.backLinks = backLinks
  } else {
    compositionElement.customBackLinks = backLinks
  }

  compositionTree.compositionElements.push(compositionElement)
}

const _isUnManaged = element => element.on && !isSelfManaged(element)

const _isNonRecursiveNavigation = (element, rootEntityName) =>
  rootEntityName !== element.target && element._isCompositionEffective

const _getLinks = element => (element.is2one && !isSelfManaged(element) ? getBackLinks(element) : [])

const _skipPersistence = (element, definitions) => definitions[element.target]._hasPersistenceSkip

const _createSubElement = (element, definitions, parentEntityName) => {
  const links = _getLinks(element, definitions)
  const backLinks = []
  const subObject = { name: element.name, backLinks, links }

  if (_skipPersistence(element, definitions)) {
    subObject.skipPersistence = true
  }

  if (_isUnManaged(element)) {
    subObject.customBackLinks = getBackLinks(element)
  }

  return subObject
}

const _isAssocComp = (element, parent) => {
  return (
    // REVISIT: are all three checks really required?
    element.target === parent.name && element.isAssociation && element.on
  )
}

const _checkIfBackLink = (element, definitions) => {
  const target = definitions[element.target]
  for (const elementName in target.elements) {
    const targetElement = target.elements[elementName]
    if (_isAssocComp(targetElement, element.parent)) {
      const onCondElements = getOnCondElements(targetElement.on)
      for (const el of onCondElements) {
        const { entityKey, targetKey } = el
        if (entityKey === `${elementName}.${element.name}` || targetKey === `${elementName}.${element.name}`) {
          return true
        }
      }
      return false
    }
  }
}

const _addBackLinksToCompositionTree = (element, definitions, compositionTree) => {
  if (_isUnManaged(element)) {
    if (_checkIfBackLink(element, definitions)) {
      const backLinks = getBackLinks(element).map(backLink => ({
        entityKey: backLink.targetKey,
        targetKey: backLink.entityKey,
        entityVal: backLink.targetVal,
        targetVal: backLink.entityVal
      }))
      compositionTree.customBackLinks.push(...backLinks)
    }
  } else {
    compositionTree.backLinks.push(...getBackLinks(element))
  }
}

const _getCompositionTreeRec = ({
  rootEntityName,
  definitions,
  compositionMap,
  compositionTree,
  entityName,
  parentEntityName,
  resolveViews
}) => {
  compositionMap.set(parentEntityName, compositionTree)
  compositionTree.source = parentEntityName
  if (parentEntityName !== rootEntityName) {
    compositionTree.target = entityName
  }
  compositionTree.compositionElements = []
  compositionTree.backLinks = compositionTree.backLinks || []
  compositionTree.customBackLinks = compositionTree.customBackLinks || []

  const parentEntity = definitions[parentEntityName]
  const elements = Object.keys(parentEntity.elements).map(key => parentEntity.elements[key])

  for (const element of elements) {
    const el = resolveViews ? _resolvedElement(element) : element
    if (_navigationExistsInCompositionMap(el, compositionMap)) {
      _addNavigationToCompositionElements(el, definitions, compositionTree, compositionMap, ctUtils.isManaged(el))
    } else if (_isNonRecursiveNavigation(el, rootEntityName)) {
      const subObject = _createSubElement(el, definitions, parentEntityName)
      compositionTree.compositionElements.push(subObject)
      _getCompositionTreeRec({
        rootEntityName,
        definitions,
        compositionMap,
        compositionTree: subObject,
        entityName: parentEntityName,
        parentEntityName: el.target
      })
    } else if (
      el._isAssociationEffective &&
      el.target === compositionTree.target &&
      isBacklink(el, el._target) &&
      compositionMap.has(el.target)
    ) {
      _addBackLinksToCompositionTree(el, definitions, compositionTree)
    }
  }
}

const _resolvedEntityName = (entityName, definitions) => {
  const target = definitions[entityName]
  if (!target) return entityName
  const resolved = getDBTable(target)
  return resolved.name
}

const _removeLocalizedTextsFromDraftTree = (compositionTree, definitions, checkedEntities = new Set()) => {
  for (const e of compositionTree.compositionElements) {
    if (checkedEntities.has(e.source)) {
      return
    }

    const target = definitions[e.target]
    if (e.name === 'texts' && target.elements.localized && !target['@fiori.draft.enabled']) {
      compositionTree.compositionElements.splice(compositionTree.compositionElements.indexOf(e), 1)
    } else {
      checkedEntities.add(e.source)
      _removeLocalizedTextsFromDraftTree(e, definitions, checkedEntities)
    }
  }
}

const _getCompositionTree = ({ definitions, rootEntityName, checkRoot = true, resolveViews = false }) => {
  const rootName = resolveViews ? _resolvedEntityName(rootEntityName, definitions) : rootEntityName

  if (checkRoot && !isRootEntity(definitions, rootEntityName)) {
    throw getError(`Entity "${rootEntityName}" is not root entity`)
  }
  const compositionTree = {}
  _getCompositionTreeRec({
    rootEntityName: rootName,
    definitions,
    compositionMap: new Map(),
    compositionTree,
    entityName: rootName,
    parentEntityName: rootName,
    resolveViews
  })

  if (definitions[rootEntityName]._isDraftEnabled) {
    _removeLocalizedTextsFromDraftTree(compositionTree, definitions)
  }

  return compositionTree
}

const _memoizeGetCompositionTree = fn => {
  const cache = new Map()
  return ({ definitions, rootEntityName, checkRoot = true, resolveViews = false }) => {
    const key = [rootEntityName, checkRoot].join('#')

    // use ApplicationService as cache key for extensibility
    // REVISIT: context._tx is not a stable API -> pls do not rely on that
    const cacheKey = (cds.context && cds.context._tx && Object.getPrototypeOf(cds.context._tx)) || definitions

    const map = cache.get(cacheKey)
    const cachedResult = map && map.get(key)
    if (cachedResult) return cachedResult

    const compTree = fn({ definitions, rootEntityName, checkRoot, resolveViews })

    const _map = map || new Map()
    _map.set(key, compTree)
    if (!map) cache.set(cacheKey, _map)

    return compTree
  }
}

/*
 * exports
 */

const getCompositionRoot = (definitions, entity) => {
  const associationElements = Object.keys(entity.elements)
    .map(key => entity.elements[key])
    .filter(element => element._isAssociationEffective)

  for (const { target } of associationElements) {
    const parentEntity = definitions[target]
    for (const parentElementName in parentEntity.elements) {
      const parentElement = parentEntity.elements[parentElementName]
      if (
        parentElement._isCompositionEffective &&
        parentElement.target === entity.name &&
        parentElement.target !== ensureNoDraftsSuffix(parentElement.parent.name)
      ) {
        return getCompositionRoot(definitions, parentEntity)
      }
    }
  }
  return entity
}

/**
 * Provides tree of all compositions. (Cached)
 *
 * @param {object} definitions Definitions of the reflected model
 * @param {string} rootEntityName Name of the root entity
 * @param {boolean} checkRoot Check is provided entity is a root
 * @returns {object} tree of all compositions
 * @throws Error if no valid root entity provided
 */
const getCompositionTree = _memoizeGetCompositionTree(_getCompositionTree)

module.exports = {
  getCompositionTree,
  getCompositionRoot
}
