/*
 * handler for filtering virtual fields by READ
 */

const _filter = (columns, target, model, remove = true, virtuals = []) => {
  if (!target) return virtuals
  let i = 0
  while (i < columns.length) {
    const col = columns[i]
    const element = col.ref && target.elements[col.ref[col.ref.length - 1]]
    if (element) {
      if (element.virtual) {
        if (remove) {
          columns.splice(i, 1)
          i--
        }
        virtuals.push(element.name)
      }
      if (col.expand && element.isAssociation) {
        const _virtuals = _filter(col.expand, model.definitions[element.target], model, remove)
        if (_virtuals.length) virtuals.push({ name: element.name, virtuals: _virtuals })
      }
    }
    i++
  }
  return virtuals
}

const _find = (columns, target, model) => _filter(columns, target, model, false)

const _handleVirtuals = (req, model, remove) => {
  // target.name ensures it is not a union or join
  if (typeof req.query === 'string' || !req.target || typeof req.target.name !== 'string' || !model) return []
  const target = (!req.target._unresolved && req.target) || model.definitions[req.target.name.replace(/_drafts$/, '')]
  const columns = (req.query && req.query.SELECT && req.query.SELECT.columns) || []
  if (!target) return []
  if (!remove && !columns.length && target && target.elements) {
    for (const el in target.elements) {
      columns.push({ ref: [el] })
    }
  }
  const _handlerFn = (!remove && _find) || _filter
  return _handlerFn(columns, target, model)
}

const getVirtuals = (req, model) => _handleVirtuals(req, model)

const removeVirtuals = function (req, model) {
  return _handleVirtuals(req, this.model || model, true)
}

const postProcessVirtuals = (virtuals, result) => {
  if (!result) return
  result = result.value && Object.keys(result).filter(k => !k.match(/^\W/)).length === 1 ? result.value : result
  const rows = Array.isArray(result) ? result : [result]
  for (const virtual of virtuals) {
    for (const row of rows) {
      if (typeof row !== 'object') continue
      if (virtual.name && row[virtual.name]) postProcessVirtuals(virtual.virtuals, row[virtual.name])
      else if (!(virtual in row)) row[virtual] = null
    }
  }
}

const getVirtualFromTarget = ({ target }) => {
  const virtuals = []
  for (const k in target.elements) {
    if (target.elements[k].virtual) virtuals.push(k)
  }
  return virtuals
}

removeVirtuals._initial = true

module.exports = {
  removeVirtuals,
  getVirtualFromTarget,
  postProcessVirtuals,
  getVirtuals
}
