const cds = require('../../cds')

const getTemplate = require('../../common/utils/template')
const templateProcessor = require('../../common/utils/templateProcessor')

const WRITE = { CREATE: 1, UPDATE: 1, DELETE: 1 }
const ASPECTS = { CREATE: '_auditCreate', READ: '_auditRead', UPDATE: '_auditUpdate', DELETE: '_auditDelete' }

/*
 * common
 */

const _getRootEntity = element => {
  let entity = element.parent
  while (entity.kind !== 'entity') entity = entity.parent
  return entity
}

// REVISIT: does this hash calc work for structured keys?
const _getHash = (entity, row) => {
  return `${entity.name}(${Object.keys(entity.keys)
    .map(k => `${k}=${row[k]}`)
    .join(',')})`
}

const _addObjectID = (log, row, key) => {
  if (!log.dataObject.id.find(ele => ele.keyName === key)) log.dataObject.id.push({ keyName: key, value: row[key] })
}

// REVISIT: better solution for data subject calculation
const _addDataSubject = (log, row, key, entity, element, model) => {
  let target = entity
  let prefix = ''
  if (element['@odata.foreignKey4']) {
    const assoc = entity.elements[element['@odata.foreignKey4']]
    target = model.definitions[assoc.target]
    prefix = assoc.name + '_'
  }
  if (!log.dataSubject.type) log.dataSubject.type = target.name
  const keyName = key.replace(prefix, '')
  if (!log.dataSubject.id.find(ele => ele.keyName === keyName)) {
    const value = row[key] || (row._old && row._old[key])
    log.dataSubject.id.push({ keyName, value })
  }
}

const _getPick = event => {
  return (element, target) => {
    if (!target[ASPECTS[event]]) return

    const categories = []
    if (!element.isAssociation && element.key) categories.push('ObjectID')
    if (!element.isAssociation && element['@PersonalData.FieldSemantics'] === 'DataSubjectID')
      categories.push('DataSubjectID')
    if (event in WRITE && element['@PersonalData.IsPotentiallyPersonal']) categories.push('IsPotentiallyPersonal')
    if (element['@PersonalData.IsPotentiallySensitive']) categories.push('IsPotentiallySensitive')
    if (categories.length) return { categories }
  }
}

/*
 * modification
 */

const _getOldAndNew = (action, row, key, sensitive) => {
  let oldValue = action === 'Create' ? null : row._old && row._old[key]
  if (oldValue === undefined) oldValue = null
  let newValue = action === 'Delete' ? null : row[key]
  if (newValue === undefined) newValue = null
  return { oldValue, newValue }
}

const _processorFnModification = (modificationLogs, model) => {
  return (row, key, element, plain) => {
    if (!row._op) return

    const entity = _getRootEntity(element)

    const action = row._op[0].toUpperCase() + row._op.slice(1)

    // create or augment log entry
    const hash = _getHash(entity, row)
    let modificationLog = modificationLogs[hash]
    if (!modificationLog) {
      modificationLogs[hash] = {
        dataObject: { type: entity.name, id: [] },
        dataSubject: { id: [], role: entity['@PersonalData.DataSubjectRole'] },
        action,
        attributes: []
      }
      modificationLog = modificationLogs[hash]
    }

    // process categories
    for (const category of plain.categories) {
      if (category === 'ObjectID') {
        _addObjectID(modificationLog, row, key)
      } else if (category === 'DataSubjectID') {
        _addDataSubject(modificationLog, row, key, entity, element, model)
      } else if (category === 'IsPotentiallyPersonal') {
        if (!modificationLog.attributes.find(ele => ele.name === key)) {
          const { oldValue, newValue } = _getOldAndNew(action, row, key)
          if (oldValue !== newValue) modificationLog.attributes.push({ name: key, oldValue, newValue })
        }
      } else if (category === 'IsPotentiallySensitive') {
        if (!modificationLog.attributes.find(ele => ele.name === key)) {
          const { oldValue, newValue } = _getOldAndNew(action, row, key, true)
          if (oldValue !== newValue) modificationLog.attributes.push({ name: key, oldValue, newValue })
        }
      }
    }
  }
}

const _getDataModificationLogs = async (data, req, tx) => {
  const template = getTemplate(
    `personal_${req.event}`.toLowerCase(),
    Object.assign({ name: req.target._service.name, model: req._model }),
    req.target,
    { pick: _getPick(req.event) }
  )

  const modificationLogs = {}
  const processFn = _processorFnModification(modificationLogs, tx.model)
  templateProcessor({ processFn, row: req._diff, template })

  return modificationLogs
}

/*
 * access
 */

const _processorFnAccess = (accessLogs, model) => {
  return (row, key, element, plain) => {
    const entity = _getRootEntity(element)

    // create or augment log entry
    const hash = _getHash(entity, row)
    let accessLog = accessLogs[hash]
    if (!accessLog) {
      accessLogs[hash] = {
        dataObject: { type: entity.name, id: [] },
        dataSubject: { id: [], role: entity['@PersonalData.DataSubjectRole'] },
        attributes: [],
        attachments: []
      }
      accessLog = accessLogs[hash]
    }

    // process categories
    for (const category of plain.categories) {
      if (category === 'ObjectID') {
        _addObjectID(accessLog, row, key)
      } else if (category === 'DataSubjectID') {
        _addDataSubject(accessLog, row, key, entity, element, model)
      } else if (category === 'IsPotentiallySensitive') {
        // add attribute
        if (!accessLog.attributes.find(ele => ele.name === key)) accessLog.attributes.push({ name: key })
        // REVISIT: attribute vs. attachment?
      }
    }
  }
}

const _getDataAccessLogs = (data, req, tx) => {
  const template = getTemplate(
    'personal_read',
    Object.assign({ name: req.target._service.name, model: req._model }),
    req.target,
    { pick: _getPick('READ') }
  )

  const accessLogs = {}
  const processFn = _processorFnAccess(accessLogs, tx.model)
  const data_ = Array.isArray(data) ? data : [data]
  data_.forEach(row => {
    templateProcessor({ processFn, row, template })
  })

  return accessLogs
}

/*
 * handler registration
 */

let als

/*
 * Generic handlers for audit logging access to writing personal data
 */

const _attachDiffToContextHandler = async function (req) {
  // REVISIT: what does this do?
  Object.defineProperty(req.query, '_selectAll', {
    enumerable: false,
    writable: false,
    configurable: true,
    value: true
  })

  // attach to root request
  req.context._diff = await req.diff()
}

const _auditModificationHandler = async function (data, req) {
  als = als || (await cds.connect.to('audit-log'))
  if (!als.ready) return

  const modificationLogs = await _getDataModificationLogs(data, req, this)
  const modifications = Object.keys(modificationLogs)
    .map(k => modificationLogs[k])
    .filter(ele => ele.attributes.length)

  if (modifications.length) await als.emit('dataModificationLog', { modifications })
}

/*
 * Generic handler for audit logging access to reading personal data
 */

const _auditAccessHandler = async function (data, req) {
  als = als || (await cds.connect.to('audit-log'))
  if (!als.ready) return

  const accessLogs = await _getDataAccessLogs(data, req, this)
  const accesses = Object.keys(accessLogs).map(k => accessLogs[k])

  if (accesses.length) await als.emit('dataAccessLog', { accesses })
}

module.exports = function () {
  /*
   * data modification
   */
  // REVISIT: diff() doesn't work in srv after phase but foreign key propagation has not yet taken place in srv before phase
  //          -> calc diff in db layer and attach to root request
  //          -> REVISIT for GA: clear req._.partialPersistentState?
  _attachDiffToContextHandler._initial = true
  for (const entity of Object.values(this.entities).filter(e => e._auditCreate)) {
    cds.db.before('CREATE', entity, _attachDiffToContextHandler)
    this.after('CREATE', entity, _auditModificationHandler)
  }
  for (const entity of Object.values(this.entities).filter(e => e._auditUpdate)) {
    cds.db.before('UPDATE', entity, _attachDiffToContextHandler)
    this.after('UPDATE', entity, _auditModificationHandler)
  }
  for (const entity of Object.values(this.entities).filter(e => e._auditDelete)) {
    cds.db.before('DELETE', entity, _attachDiffToContextHandler)
    this.after('DELETE', entity, _auditModificationHandler)
  }

  /*
   * data access
   */
  for (const entity of Object.values(this.entities).filter(e => e._auditRead)) {
    this.after('READ', entity, _auditAccessHandler)
  }
}
