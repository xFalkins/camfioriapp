const cds = require('../../cds')
const LOG = cds.log('remote')

const { revertData } = require('../../common/utils/resolveView')
const generateQuery = require('../cqn2odata')
const { convertV2ResponseData } = require('./dataConversion')

let _cloudSdkCore

const PPPD = {
  POST: 1,
  PUT: 1,
  PATCH: 1,
  DELETE: 1
}

const _executeHttpRequest = (...args) => {
  if (!_cloudSdkCore) _cloudSdkCore = require('@sap-cloud-sdk/core')

  const opts = args[1]
  if (PPPD[opts.method] && cds.env.features.fetch_csrf) {
    if (args.length === 3) args[2].fetchCsrfToken = true
    else args.push({ fetchCsrfToken: true })
  }

  return _cloudSdkCore.executeHttpRequest(...args)
}

const findServiceName = (model, ds, options) => {
  const modelServices = Object.values(model.services)

  if (options.credentials && options.credentials.service) {
    if (!modelServices.find(srv => srv.name === options.credentials.service)) {
      throw new Error(`Service "${options.credentials.service}" not found in provided model`)
    }

    return options.credentials.service
  }

  return ds
}

const createDestinationObject = (name, credentials) => {
  if (!credentials) {
    throw new Error(`No credentials configured for "${name}"`)
  }

  if (!credentials.url) {
    throw new Error(`No url configured in credentials for "${name}"`)
  }

  return { name, ...credentials }
}

const getKind = options => {
  const kind = (options.credentials && options.credentials.kind) || options.kind
  if (typeof kind === 'object') {
    const k = Object.keys(kind).find(
      key => key === 'odata' || key === 'odata-v4' || key === 'odata-v2' || key === 'rest'
    )
    // odata-v4 is equivalent of odata
    return k === 'odata-v4' ? 'odata' : k
  }

  return kind
}

/**
 * Rest Client
 */
/**
 * Normalizes server path.
 *
 * Adds / in the beginning of the path if not exists.
 * Removes / in the end of the path if exists.
 *
 * @param {*} path - to be normalized
 */
const formatPath = path => {
  let formattedPath = path
  if (!path.startsWith('/')) {
    formattedPath = `/${formattedPath}`
  }

  if (path.endsWith('/')) {
    formattedPath = formattedPath.substring(0, formattedPath.length - 1)
  }

  return formattedPath
}
// creates a map with key "remote origin name" and value { as: "projection name"}
// if it is an expand, it contains an additional property .expand with classic ref/as syntax
// ref/as syntax is kept in order to reuse handleAliasInResult
const _createAliasMap = columns => {
  if (columns) {
    let aliasMap
    for (const col of columns) {
      const processor = {}
      if (col.as) {
        processor.as = col.as
        ;(aliasMap || (aliasMap = new Map())) && aliasMap.set(col.ref[col.ref.length - 1], processor)
      }
      if (col.expand) {
        processor.expand = col.expand
      }
    }

    return aliasMap
  }
}

// Transforms the result of the remote service according to the provided aliases
const handleAliasInResult = (columns, result) => {
  const postProcessor = _createAliasMap(columns)
  const resultArray = Array.isArray(result) ? result : [result]
  if (postProcessor) {
    for (const row of resultArray) {
      // we need to use a cache because of cross renamings
      // e. g. column a is renamed to b and column b is renamed to a
      const tempCache = new Map()

      for (const col in row) {
        const processor = postProcessor.get(col)
        if (processor && processor.as !== col) {
          // if a value for the alias is already present, add it to the cache
          if (row[processor.as]) {
            tempCache.set(processor.as, row[processor.as])
          }

          // get the value from cache if present
          row[processor.as] = tempCache.get(col) || row[col]

          // if it was not overridden because of a renaming,
          // delete it from the row
          if (!tempCache.has(processor.as)) {
            delete row[col]
          }
        }

        if (processor && processor.expand) {
          handleAliasInResult(processor.expand, row[processor.as || col])
        }
      }
    }
  }
}

function _defineProperty(obj, property, value) {
  const props = {}
  if (Array.isArray(obj)) {
    const _map = obj.map
    const map = (..._) => _defineProperty(_map.call(obj, ..._), property, value)
    props.map = { value: map, enumerable: false, configurable: true, writable: true }
  }
  props[property] = { value: value, enumerable: false, configurable: true, writable: true }
  for (const prop in props) {
    Object.defineProperty(obj, prop, props[prop])
  }
  return obj
}

function _normalizeMetadata(prefix, data, results) {
  const target = results || data
  if (typeof target !== 'object') return target
  const metadataKeys = Object.keys(data).filter(k => prefix.test(k))
  for (const k of metadataKeys) {
    const $ = k.replace(prefix, '$')
    _defineProperty(target, $, data[k])
    delete target[k]
  }
  if (Array.isArray(target)) {
    return target.map(row => _normalizeMetadata(prefix, row))
  }
  // check properties for all and prop.results for odata v2
  for (const [key, value] of Object.entries(target)) {
    if (value && typeof value === 'object') {
      const nestedResults = (Array.isArray(value.results) && value.results) || value
      target[key] = _normalizeMetadata(prefix, value, nestedResults)
    }
  }
  return target
}

const _purgeODataV2 = (data, target, reqHeaders) => {
  if (typeof data !== 'object' || !data.d) return data

  data = data.d
  const contentType = reqHeaders['content-type']
  const ieee754Compatible = contentType && contentType.includes('IEEE754Compatible=true')
  const purgedResponse = data.results || data
  const convertedResponse = convertV2ResponseData(purgedResponse, target, ieee754Compatible)
  return _normalizeMetadata(/^__/, data, convertedResponse)
}

const _purgeODataV4 = data => {
  if (typeof data !== 'object') return data

  const purgedResponse = data.value || data
  return _normalizeMetadata(/^@odata\./, data, purgedResponse)
}

const TYPES_TO_REMOVE = { function: 1, object: 1 }
const PROPS_TO_IGNORE = { cause: 1, name: 1 }

const _getSanitizedError = (e, reqOptions) => {
  e.request = {
    method: reqOptions.method,
    url: e.config ? e.config.baseURL + e.config.url : reqOptions.url,
    headers: e.config ? e.config.headers : reqOptions.headers
  }

  if (e.response) {
    const response = {
      status: e.response.status,
      statusText: e.response.statusText,
      headers: e.response.headers
    }
    if (e.response.data && e.response.data.error) response.body = e.response.data
    e.response = response
  }

  const correlationId =
    (cds.context && cds.context.id) || (reqOptions.headers && reqOptions.headers['x-correlation-id'])
  if (correlationId) e.correlationId = correlationId

  // sanitize authorization
  if (e.request.headers && e.request.headers.authorization)
    e.request.headers.authorization = e.request.headers.authorization.split(' ')[0] + ' ...'

  // delete functions and complex objects in config
  for (const k in e) if (typeof e[k] === 'function') delete e[k]
  if (e.config) for (const k in e.config) if (TYPES_TO_REMOVE[typeof e.config[k]]) delete e.config[k]

  // REVISIT: ErrorWithCause log waaay to much -> copy what we want to new object (as delete e.cause doesn't work)
  if (e.cause) {
    let msg = ''
    let cur = e.cause
    while (cur) {
      msg += ' Caused by: ' + cur.message
      cur = cur.cause
    }
    const _e = { message: e.message + msg }
    for (const k of [...Object.keys(e).filter(k => !PROPS_TO_IGNORE[k])]) _e[k] = e[k]
    e = _e
  }

  return e
}

const run = async (reqOptions, { destination, jwt, kind, resolvedTarget }) => {
  const dest = typeof destination === 'string' ? { destinationName: destination, jwt } : destination

  let response
  try {
    response = await _executeHttpRequest(dest, reqOptions)
  } catch (e) {
    // > axios received status >= 400 -> gateway error
    e.message = e.message ? 'Error during request to remote service: ' + e.message : 'Request to remote service failed.'

    const sanitizedError = _getSanitizedError(e, reqOptions)

    LOG._warn && LOG.warn(sanitizedError)

    throw Object.assign(new Error(e.message), { statusCode: 502, innererror: sanitizedError })
  }

  // text/html indicates a redirect -> reject
  if (
    response.headers &&
    response.headers['content-type'] &&
    response.headers['content-type'].includes('text/html') &&
    !(
      reqOptions.headers.accept.includes('text/html') ||
      reqOptions.headers.accept.includes('text/*') ||
      reqOptions.headers.accept.includes('*/*')
    )
  ) {
    const e = new Error("Received content-type 'text/html' which is not part of accepted content types")
    e.response = response

    const sanitizedError = _getSanitizedError(e, reqOptions)

    LOG._warn && LOG.warn(sanitizedError)

    throw Object.assign(new Error(`Error during request to remote service: ${e.message}`), {
      statusCode: 502,
      innererror: sanitizedError
    })
  }

  if (kind === 'odata-v4') return _purgeODataV4(response.data)
  if (kind === 'odata-v2') return _purgeODataV2(response.data, resolvedTarget, reqOptions.headers)
  if (kind === 'odata') {
    if (typeof response.data !== 'object') return response.data
    // try to guess if we need to purge v2 or v4
    if (response.data.d) {
      return _purgeODataV2(response.data, resolvedTarget, reqOptions.headers)
    }
    return _purgeODataV4(response.data)
  }
  return response.data
}

const getJwt = req => {
  const headers = req && req.context && req.context.headers
  if (headers && headers.authorization) {
    const token = headers.authorization.match(/^bearer (.+)/i)
    if (token) {
      return token[1]
    }
  }
  return null
}

const _cqnToReqOptions = (query, kind, model) => {
  const queryObject = generateQuery(query, kind, model)
  return {
    method: queryObject.method,
    url: encodeURI(
      queryObject.path
        // ugly workaround for Okra not allowing spaces in ( x eq 1 )
        .replace(/\( /g, '(')
        .replace(/ \)/g, ')')
    ),
    data: queryObject.body
  }
}

const _stringToReqOptions = (query, data) => {
  const cleanQuery = query.trim()
  const blankIndex = cleanQuery.substring(0, 8).indexOf(' ')
  const reqOptions = {
    method: cleanQuery.substring(0, blankIndex).toUpperCase(),
    url: encodeURI(formatPath(cleanQuery.substring(blankIndex, cleanQuery.length).trim()))
  }
  if (data && reqOptions.method !== 'GET' && reqOptions.method !== 'HEAD') reqOptions.data = data
  return reqOptions
}

const _pathToReqOptions = (method, path, data) => {
  let url = path
  if (!url.startsWith('/')) {
    // extract entity name and instance identifier (either in "()" or after "/") from fully qualified path
    const parts = path.match(/([\w.]*)([\W.]*)(.*)/)
    if (!parts) url = '/' + path.match(/\w*$/)[0]
    else url = '/' + parts[1].match(/\w*$/)[0] + parts[2] + parts[3]

    // normalize in case parts[2] already starts with /
    url = url.replace(/^\/\//, '/')
  }
  const reqOptions = { method, url }
  if (data && reqOptions.method !== 'GET' && reqOptions.method !== 'HEAD') reqOptions.data = data
  return reqOptions
}

const getReqOptions = (req, query, service) => {
  const reqOptions =
    typeof query === 'object'
      ? _cqnToReqOptions(query, service.kind, service.model)
      : typeof query === 'string'
      ? _stringToReqOptions(query, req.data)
      : _pathToReqOptions(req.method, req.path, req.data)

  reqOptions.headers = { accept: 'application/json,text/plain' }
  reqOptions.timeout = service.requestTimeout

  if (reqOptions.data && reqOptions.method !== 'GET' && reqOptions.method !== 'HEAD') {
    reqOptions.headers['content-type'] = 'application/json'
    reqOptions.headers['content-length'] = Buffer.byteLength(JSON.stringify(reqOptions.data))
  }

  reqOptions.url = formatPath(reqOptions.url)

  if (service.path) reqOptions.url = `${encodeURI(service.path)}${reqOptions.url}`

  return reqOptions
}

// REVISIT: todo renaming for expanded entities
// REVISIT: todo renaming for deep operations
const postProcess = (query, result) => {
  if (query.SELECT) {
    handleAliasInResult(query.SELECT.columns, result)
    return typeof query === 'object' && query.SELECT.one && Array.isArray(result) ? result[0] : result
  }
  if (query.DELETE) return result
  let transition
  if (query.INSERT) transition = query.INSERT._transitions[query.INSERT._transitions.length - 1]
  if (query.UPDATE) transition = query.UPDATE._transitions[query.UPDATE._transitions.length - 1]
  return revertData(result, transition)
}

const getAdditionalOptions = (req, destination, kind, resolvedTarget) => {
  const jwt = getJwt(req)
  const additionalOptions = { destination, kind, resolvedTarget }
  if (jwt) additionalOptions.jwt = jwt
  return additionalOptions
}

const getDestination = (model, datasource, options) =>
  createDestinationObject(findServiceName(model, datasource, options), options.credentials)

module.exports = {
  getKind,
  run,
  getReqOptions,
  postProcess,
  getDestination,
  getAdditionalOptions
}
