const { computeColumnsToBeSearched } = require('../cds-services/services/utils/columns')
const searchToLike = require('../common/utils/searchToLike')
const { isContainsPredicateSupported, searchToContains } = require('./searchToContains')
const { getOnCond } = require('../common/utils/generateOnCond')

/**
 * Computes a CQN expression for a search query.
 *
 * For performance reasons, search queries over localized elements use the `CONTAINS` predicate in the `WHERE` clause
 * of a `SELECT` statement instead of the `LIKE` predicate when possible. The `LIKE` predicate might cause a high CPU
 * load on SAP HANA servers because the SAP HANA optimizer cannot push down `LIKE` expressions to the column storage
 * layer. As a result, search queries over large data sets are slow.
 *
 * The `CONTAINS` predicates with exact search option (default behavior) is rendered as `LIKE` by the HANA optimizer.
 * But in contrast to the explicitly written `LIKE ?`, the parameter is already resolved to its concrete value, making
 * it better optimizable by the HANA optimizer.
 *
 * @param {object} cqn The CQN object
 * @param {import('@sap/cds-compiler/lib/api/main').CSN} entity The target entity for the search query
 * @param {import('../types/api').search2cqnOptions} [options]
 * @returns {object} The modified CQN object
 */
const search2cqn4sql = (cqn, entity, options) => {
  const cqnSearchPhrase = cqn.SELECT.search
  if (!cqnSearchPhrase) return cqn

  let { columns = computeColumnsToBeSearched(cqn, entity), locale } = options
  const localizedAssociation = _getLocalizedAssociation(entity)

  // If the localized association is defined for the target entity,
  // there should be at least one localized element.
  const resolveLocalizedTextsAtRuntime = !!localizedAssociation

  if (resolveLocalizedTextsAtRuntime) {
    // suppress the localize handler from modifying the from target
    // The `_suppressLocalization` property is:
    // enumerable: false (default), writable: false (default)
    Object.defineProperty(cqn, '_suppressLocalization', { value: true })

    const onConditionOptions = _getOnConditionOptions(entity, localizedAssociation)
    const onCondition = getOnCond(localizedAssociation, onConditionOptions)

    // replace $user_locale placeholder with the user locale or the HANA session context
    onCondition[onCondition.length - 2].ref[0] = `'${locale}'` || "SESSION_CONTEXT('LOCALE')"

    // inner join the target table with the _texts table (the _texts table contains
    // the translated texts)
    const localizedEntityName = localizedAssociation.target
    cqn.join(localizedEntityName).on(onCondition)

    // The inner join modifies the original SELECT ... FROM query and adds ambiguity,
    // therefore add the table/entity name (as a preceding element) to the columns ref
    // to prevent a SQL ambiguity error. E.g., SqlError message: column ambiguously
    // defined.
    cqn.SELECT.columns = _unshiftEntityNameToColumnRef(entity, cqn.SELECT.columns)
    columns = _unshiftEntityNameToColumnRef(entity, columns)
  } // else --> resolve localized texts via localized view (default)

  const useContains = resolveLocalizedTextsAtRuntime && isContainsPredicateSupported(cqn)
  let expression

  if (useContains) {
    expression = searchToContains(cqnSearchPhrase, columns)
  } else {
    // No CONTAINS optimization possible. The search implementation for localized
    // texts falls back to the LIKE predicate.
    expression = searchToLike(cqnSearchPhrase, columns)
  }

  // REVISIT: find out here if where or having must be used
  cqn._aggregated ? cqn.having(expression) : cqn.where(expression)
  return cqn
}

const _getLocalizedAssociation = entity => {
  const associations = entity.associations
  return associations && associations.localized
}

const _getOnConditionOptions = (entity, localizedAssociation) => {
  return {
    associationNames: [localizedAssociation.name],
    aliases: {
      select: localizedAssociation.target,
      join: entity.name
    }
  }
}

const _unshiftEntityNameToColumnRef = (entity, columns) => {
  const localizedEntityName = _getLocalizedAssociation(entity).target
  const elements = entity.elements

  columns = columns.map(column => {
    const columnRef = column.ref
    if (!columnRef) return column
    const columnName = columnRef[0]
    const localizedElement = elements[columnName].localized
    const entityName = localizedElement ? localizedEntityName : entity.name
    return { ref: [entityName, columnName] }
  })

  return columns
}

module.exports = search2cqn4sql
