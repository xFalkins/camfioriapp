'use strict';

const { forAllQueries, forEachDefinition } = require('../../model/csnUtils');
const { setProp } = require('../../base/model');
const { getRealName } = require('../../render/utils/common');

/**
 * Turn a `exists assoc[filter = 100]` into a `exists (select 1 as dummy from assoc.target where <assoc on condition> and assoc.target.filter = 100)`.
 *
 * Sample: select * from E where exists assoc[filter=100]
 *
 * E: assoc with target F, id as key
 * F: id as key, filter: Integer
 *
 * For a managed association `assoc`:
 * - For each of the foreign keys, create <assoc.target, assoc.target.key.ref> = <query source, assoc name, assoc.target.key.ref>
 *
 * Given the sample above:
 * - F.id = E.assoc.id -> which will later on be translated to the real foreign key E.assoc_id
 *
 * The final subselect looks like (select 1 as dummy from F where F.id = E.assoc.id and filter = 100).
 *
 * For an unmanaged association:
 * - For each part of the on-condition, we check:
 *   + Is it part of the target side: <assoc>.<path> is turned into <assoc.target>.<path>
 *   + Is it part of the source side: <path> is turned into <query source>.<path> - a leading $self is stripped-off
 *   + Is it something else: Don't touch it, leave as is
 *
 * Given that `assoc` from above has the on-condition assoc.id = id, we would generate the following:
 * - F.id = E.id
 *
 * The final subselect looks like (select 1 as dummy from E where F.id = E.id and filter = 100).
 *
 * For a $self backlink:
 * - For $self = <assoc>.<another-assoc>, we do the following for each foreign key of <another-assoc>
 *   + <assoc>.<another-assoc>.<fk> -> <assoc.target>.<another-assoc>.<fk>
 *   + Afterwards, we get the corresponding key from the source side: <query-source>.<fk>
 *   + And turn this into a comparison: <assoc.target>.<another-assoc>.<fk> = <query-source>.<fk>
 *
 * So for the sample above, given an on-condition like $self = assoc.backToE, we would generate:
 * - F.backToE.id = E.id
 *
 * The final subselect looks like (select 1 as dummy from E where F.backToE.id = E.id and filter = 100).
 *
 * @param {CSN.Model} csn
 * @param {Function} error
 */
function handleExists(csn, error) {
  forEachDefinition(csn, (artifact, artifactName) => {
    if (artifact.query) {
      forAllQueries(artifact.query, (query) => {
        if (!query.$generatedExists) {
          if (query.SELECT && query.SELECT.where && query.SELECT.where.length > 1)
            query.SELECT.where = processExists(query, query.SELECT.where);


          if (query.SELECT && query.SELECT.columns)
            query.SELECT.columns = processExists(query, query.SELECT.columns);


          if (query.SELECT && query.SELECT.from.on )
            query.SELECT.from.on = processExists(query, query.SELECT.from.on);
        }
      }, [ 'definitions', artifactName, 'query' ]);
    }
  });

  /**
   * Get the source aliases from a join
   *
   * @param {Array} args Join args
   * @returns {object}
   */
  function getJoinSources(args) {
    let sources = Object.create(null);
    for (const join of args) {
      if (join.as) {
        sources[join.as] = join.as;
      }
      else if (join.args) {
        const subsources = getJoinSources(join.args);
        sources = Object.assign(sources, subsources);
      }
      else if (join.ref) {
        sources[join.ref[join.ref.length - 1]] = join.ref[join.ref.length - 1];
      }
    }

    return sources;
  }

  /**
   * Get the source aliases from a query - drill down somewhat into joins (is that correct?)
   *
   * @param {CSN.Query} query
   * @returns {object}
   */
  function getQuerySources(query) {
    const sources = Object.create(null);
    if (query.from.as)
      sources[query.from.as] = query.from.as;
    else if (query.from.args)
      return Object.assign(sources, getJoinSources(query.from.args));
    else if (query.from.ref)
      sources[query.from.ref[query.from.ref.length - 1]] = query.from.ref[query.from.ref.length - 1];

    return sources;
  }

  /**
   * Process the given expr of the given query and translate a `EXISTS assoc` into a `EXISTS (subquery)`.
   *
   * @param {CSN.Query} query
   * @param {TokenStream} expr
   * @returns {TokenStream} A new token stream expression - the same as expr, but with the expanded EXISTS
   */
  function processExists(query, expr) {
    const newExpr = [];
    const queryBase = query.SELECT.from.ref ? (query.SELECT.from.as || query.SELECT.from.ref[0]) : null;
    const sources = getQuerySources(query.SELECT);

    for (let i = 0; i < expr.length; i++) {
      if (i < expr.length - 1 && expr[i] === 'exists' && expr[i + 1].ref) {
        i++;
        const current = expr[i];
        const isPrefixedWithTableAlias = firstLinkIsEntityOrQuerySource(current);
        const base = getBase(queryBase, isPrefixedWithTableAlias, current);
        const { root, ref, tail } = getFirstAssoc(current);

        if (tail.length > 0) {
          error(null, current.$path, { id: tail[0], name: ref.id ? ref.id : ref }, 'Unexpected path step $(ID) after association $(NAME) in "EXISTS"');
          continue;
        }

        if (!root.target)
          return error(null, current.$path, { type: root.type }, '"EXISTS" can only be used with associations/compositions, found $(TYPE)');

        const subselect = getSubselect(root.target, ref, sources);

        const target = subselect.SELECT.from.as; // use subquery alias as target - prevent shadowing
        if (root.keys) { // managed assoc
          translateManagedAssocToWhere(root, target, subselect, isPrefixedWithTableAlias, base, current);
        }
        else { // unmanaged assoc
          translateUnmanagedAssocToWhere(root, target, subselect, isPrefixedWithTableAlias, base, current);
        }

        newExpr.push('exists');
        if (ref && ref.where)
          subselect.SELECT.where.push(...[ 'and', ...remapExistingWhere(target, ref.where) ]);

        newExpr.push(subselect);
      }
      else { // Drill down into other places that might contain a `EXISTS <assoc>`
        if (expr[i].xpr)
          expr[i].xpr = processExists(query, expr[i].xpr);
        if (expr[i].args && Array.isArray(expr[i].args))
          expr[i].args = processExists(query, expr[i].args);

        newExpr.push(expr[i]);
      }
    }

    return newExpr;
  }

  /**
   * Translate an `EXISTS <managed assoc>` into a part of a WHERE condition.
   *
   * For each of the foreign keys, do:
   * + build the target side by prefixing `target` infront of the ref
   * + build the source side by prefixing `base` (if not already part of `current`)
   *  and the assoc name itself (current) infront of the ref
   * + Compare source and target with `=`
   *
   * If there is more than one foreign key, join with `and`.
   *
   * The new tokens are immediatly added to the WHERE of the subselect
   *
   * @param {CSN.Element} root
   * @param {string} target
   * @param {CSN.Query} subselect This subselect will in the end replace <assoc> in EXISTS <assoc>
   * @param {boolean} isPrefixedWithTableAlias
   * @param {string} base
   * @param {Token} current
   */
  function translateManagedAssocToWhere(root, target, subselect, isPrefixedWithTableAlias, base, current) {
    for (let j = 0; j < root.keys.length; j++) {
      const lop = { ref: [ target, ...root.keys[j].ref ] }; // target side
      const rop = { ref: (isPrefixedWithTableAlias ? [] : [ base ]).concat([ ...toRawRef(current.ref), ...root.keys[j].ref ]) }; // source side

      if (j > 0)
        subselect.SELECT.where.push('and');

      subselect.SELECT.where.push(...[ lop, '=', rop ]);
    }
  }

  /**
   * Turn a ref-array into an array of strings.
   *
   * @param {Array} ref Array of strings or objects with `id`
   * @returns {string[]}
   */
  function toRawRef(ref) {
    return ref.map(r => (r.id ? r.id : r));
  }

  /**
   * Translate an `EXISTS <unmanaged assoc>` into a part of a WHERE condition.
   *
   * A valid $self-backlink is handled in translateDollarSelfToWhere.
   *
   * For an ordinary unmanaged association, we do the the following for each part of the on-condition:
   * - target side: We prefix the real target and cut off the assoc-name from the ref
   * - source side w/ leading $self: We remove the $self and add the source side entity/query source
   * - source side w/o leading $self: We simply add the source side entity/query source in front of the ref
   * - all other: Leave intact, usually operators
   *
   * @param {CSN.Element} root
   * @param {string} target
   * @param {CSN.Query} subselect This subselect will in the end replace <assoc> in EXISTS <assoc>
   * @param {boolean} isPrefixedWithTableAlias
   * @param {string} base
   * @param {Token} current
   */
  function translateUnmanagedAssocToWhere(root, target, subselect, isPrefixedWithTableAlias, base, current) {
    for (let j = 0; j < root.on.length; j++) {
      const part = root.on[j];
      // Dollar Self Backlink
      if (isValidDollarSelf(root.on[j], root.on[j + 1], root.on[j + 2])) {
        if (root.on[j].ref[0] === '$self' && root.on[j].ref.length === 1)
          subselect.SELECT.where.push(...translateDollarSelfToWhere(base, target, root.on[j + 2]));
        else
          subselect.SELECT.where.push(...translateDollarSelfToWhere(base, target, root.on[j]));

        j += 2;
      }
      else if (part._links && part._links[0].art === root) { // target side
        subselect.SELECT.where.push({ ref: [ target, ...part.ref.slice(1) ] });
      }
      else if (part.$scope === '$self') { // source side - "absolute" scope
        // cut off the $self, as we prefix the entity name now
        subselect.SELECT.where.push({ ref: [ base, ...part.ref.slice(1) ] });
      }
      else if (part._art) { // source side - with local scope
        if (isPrefixedWithTableAlias)
          subselect.SELECT.where.push({ ref: [ ...current.ref.slice(0, -1), ...part.ref ] });
        else
          subselect.SELECT.where.push({ ref: [ base, ...current.ref.slice(0, -1), ...part.ref ] });
      }
      else { // operator - or any other leftover
        subselect.SELECT.where.push(part);
      }
    }

    /**
     * Check that an expression triple is a valid $self
     *
     * @param {Token} leftSide
     * @param {Token} middle
     * @param {Token} rightSide
     * @returns {boolean}
     */
    function isValidDollarSelf(leftSide, middle, rightSide) {
      return leftSide && leftSide.ref &&
      rightSide && rightSide.ref &&
      middle === '=' &&
                      (
                        leftSide.ref[0] === '$self' && leftSide.ref.length === 1 && rightSide._art && rightSide._art.target ||
                        rightSide.ref[0] === '$self' && rightSide.ref.length === 1 && leftSide._art && leftSide._art.target
                      );
    }
  }

  /**
   * From the given expression (having _links), find the first association.
   *
   * @param {object} xprPart
   * @returns {{root: CSN.Element, ref: string|object, tail: Array}} The first assoc (root), the corresponding ref (ref) and the rest of the ref (tail).
   */
  function getFirstAssoc(xprPart) {
    for (let i = 0; i < xprPart.ref.length - 1; i++) {
      if (xprPart._links[i].art && xprPart._links[i].art.target)
        return { root: xprPart._links[i].art, ref: xprPart.ref[i], tail: xprPart.ref.slice(i + 1) };
    }
    return { root: xprPart._art, ref: xprPart.ref[xprPart.ref.length - 1], tail: [] };
  }

  /**
   * Check (using _links), wether the first path step is an entity or query source
   *
   * @param {object} o
   * @returns {boolean}
   */
  function firstLinkIsEntityOrQuerySource(o) {
    return o._links && (o._links[0].art.kind === 'entity' || o._links[0].art.query || o._links[0].art.from);
  }

  /**
   * For a given xpr, check in which entity/query source the ref "is".
   *
   * If the ref already starts with an entity/query source, simply return the first ref step.
   * Otherwise, use $env to figure it out:
   * - $env=<string> -> the string is the source
   * - $env=<number> && $scope='mixin' -> the current query is the source
   * - $env=<number> && $scope!=='mixin' -> such refs start with entity/query source, are already handled
   * - $env=true -> does not apply for "EXISTS" handling, only happens in ORDER BY or explicit on-cond redirection
   *
   * If we have a ref but no $env, throw to trigger recompile - but such cases should have already led to a recompile with
   * the validator/enricher.
   *
   * Since we only call this function when it is not just a simple SELECT FROM X,
   * we can be sure that resolving the ref requires $env information.
   *
   * @param {object} xpr
   * @returns {string|undefined} undefined in case of errors
   * @throws {Error} Throws if xpr.ref but no xpr.$env
   * @todo $env is going to be removed from CSN, but csnRefs will provide it
   */
  // eslint-disable-next-line consistent-return
  function getParent(xpr) {
    if (firstLinkIsEntityOrQuerySource(xpr)) {
      return xpr.ref[0];
    }
    else if (xpr.$env) {
      if (typeof xpr.$env === 'string') {
        return xpr.$env;
      }
      else if (typeof xpr.$env === 'number') {
        if (xpr.$scope === 'mixin')
          return '';
        return error(null, xpr.$path, '$env with number is not handled yet - please report this error!');
      }

      return error(null, xpr.$path, 'Boolean $env is not handled yet - please report this error!');
    }
    else if (xpr.ref) {
      throw new Error('Missing $env and missing leading artifact ref - throwing to trigger recompilation!');
    }
  }

  /**
   * Build an initial subselect for the final `EXISTS <subselect>`.
   *
   * @param {string} target The target of `EXISTS <assoc>` - will be selected from
   * @param {string|object} assocRef The ref "being" the association
   * @param {object} _sources Object containing the names of the query sources of the current query
   * @returns {CSN.Query}
   */
  function getSubselect(target, assocRef, _sources) {
    let subselectAlias = `_${assocRef.id ? assocRef.id : assocRef}_exists`;

    while (_sources[subselectAlias])
      subselectAlias = `_${subselectAlias}`;

    const subselect = {
      SELECT: {
        // use alias to prevent shadowing of upper-level table alias
        from: { ref: [ target ], as: subselectAlias },
        columns: [ { val: 1, as: 'dummy' } ],
        where: [],
      },
    };
    // Because the generated things don't have _links, _art etc. set
    // We could also make getParent more robust to calculate the links JIT if they are missing
    setProp(subselect, '$generatedExists', true);

    const nonEnumElements = Object.create(null);
    nonEnumElements.dummy = {
      type: 'cds.Integer',
    };

    setProp(subselect.SELECT, 'elements', nonEnumElements);

    return subselect;
  }

  /**
   * Get the name of the source-side query source
   *
   * @param {string|null} queryBase
   * @param {boolean} isPrefixedWithTableAlias
   * @param {CSN.Column} current
   * @returns {string}
   */
  function getBase(queryBase, isPrefixedWithTableAlias, current) {
    if (queryBase)
      return getRealName(csn, queryBase);
    else if (isPrefixedWithTableAlias)
      return current.ref[0];
    return getParent(current);
  }


  /**
   * If the assoc-base for EXISTS <assoc> has a filter, we need to merge this filter into the WHERE-clause of the subquery.
   *
   * This function does this by adding the assoc target before all the refs so that the refs are resolvable in the WHERE.
   *
   * @param {string} target
   * @param {TokenStream} where
   * @returns {TokenStream} The input-where with the refs "absolutified"
   */
  function remapExistingWhere(target, where) {
    return where.map((part) => {
      if (part.ref) {
        part.ref = [ target, ...part.ref ];
        return part;
      }

      return part;
    });
  }

  /**
   * Turn the would-be on-condition of a $self backlink into a WHERE condition.
   *
   * Prefix the target/source side base accordingly and build the source = target comparisons.
   *
   * @param {string} base The source entity/query source name
   * @param {string} target The target entity/query source name
   * @param {CSN.Element} assoc The association element - the "not-$self" side of the comparison
   * @returns {TokenStream} The WHERE representing the $self comparison
   */
  function translateDollarSelfToWhere(base, target, assoc) {
    const where = [];
    if (assoc._art.keys) {
      for (let i = 0; i < assoc._art.keys.length; i++) {
        const lop = { ref: [ target, ...assoc.ref.slice(1), ...assoc._art.keys[i].ref ] }; // target side
        const rop = { ref: [ base, ...assoc._art.keys[i].ref ] }; // source side
        if (i > 0)
          where.push('and');

        where.push(...[ lop, '=', rop ]);
      }
    }
    else if (assoc._art.on) {
      for (let i = 0; i < assoc._art.on.length; i++) {
        const part = assoc._art.on[i];
        if (part._links && part._links[0].art === assoc._art) { // target side
          where.push({ ref: [ base, ...part.ref.slice(1) ] });
        }
        else if (part.$scope === '$self') { // source side - "absolute" scope
          // Same message as in forHanaNew/transformDollarSelfComparisonWithUnmanagedAssoc
          error(null, part.$path, 'An association that uses "$self" in its ON-condition can\'t be compared to "$self"');
        }
        else if (part._art) { // source side - with local scope
          where.push({ ref: [ target, ...assoc.ref.slice(1, -1), ...part.ref ] });
        }
        else { // operator - or any other leftover
          where.push(part);
        }
      }
    }
    return where;
  }
}


module.exports = handleExists;

/**
 * @typedef {Token[]} TokenStream Array of tokens.
 */

/**
 * @typedef {string|object} Token Could be an object or a string - strings are usually operators.
 */
