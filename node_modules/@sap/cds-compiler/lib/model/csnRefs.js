// CSN functionality for resolving references
//
// The functions in this module expect a well-formed CSN with valid references.
// If that is not the case, it simply throws an error (which might even be a
// plain TypeError) without any claim for the error message to be
// user-friendly.  CSN processors can provide user-friendly error messages by
// calling the Core Compiler in that case.  For details, see
// internalDoc/CoreCompiler.md#use-of-the-core-compiler-for-csn-processors.
//
// For details about the name resolution in CSN, see
// internalDoc/CsnSyntax.md#helper-property-for-simplified-name-resolution
// and doc/NameResolution.md.
//
// Terminology used in this file:
//
// - ref (reference): a { ref: <path> } object (or sometimes also a string)
//   referring an artifact or member
// - path: an array of strings or { id: â€¦ } objects for the dot-connected names
//   used as reference
// - csnPath: an array of strings and numbers (e.g. ['definitions', 'S.E',
//   'query', 'SELECT', 'from', 'ref', 0]); they are the property names and
//   array indexes which navigate from the CSN root to the current node.

// TODO: think of using the term `query` for the thing inside SELECT/SET.

'use strict';

const BUILTIN_TYPE = {};
const { locationString } = require('../base/location');

// Properties in which artifact or members are defined - next property in the
// "csnPath" is the name or index of that property; 'args' (its value can be a
// dictionary) is handled extra here, also 'expand' and 'inline'
const artifactProperties = [ 'elements', 'columns', 'keys', 'mixin', 'enum',
  'params', 'actions', 'definitions', 'extensions' ]; // + 'args', see above

const scopeSpecs = {
  type: { global: true },
  includes: { global: true },
  target: { global: true },
  from: { global: true },
  keys: { lexical: false, dynamic: 'target' },
  excluding: { lexical: false },
  expand: { lexical: justDollar },       // dynamic: 'baseEnv-or-source'
  inline: { lexical: justDollar },       // dynamic: 'baseEnv'
  'ref-target': { lexical: justDollar }, // dynamic: 'baseEnv'
  on: { lexical: justDollar, dynamic: 'query' }, // assoc defs, redirected to
  orderBy: { dynamic: 'query' },
  'orderBy-set': { lexical: query => query.$next, dynamic: 'query' }, // to outer SELECT (from UNION)
  // default: { lexical: query => query, dynamic: 'source' }
}

function justDollar() {
  return null;
}

/**
 * @param {CSN.Model} csn
 */
function csnRefs( csn ) {
  const cache = new WeakMap();

  // TODO: code cleanup after getting rid of $env
  resolveRef.expand = function resolveRefExpand( obj, ...args ) {
    return cached( obj, '_env', () => navigationEnv( resolveRef( obj, ...args ).art ) );
  }
  resolveRef.refWhere = function resolveRefWhere( refObj, obj, ...args ) {
    return cached( obj, '_env', () => {
      resolveRef( refObj, ...args ); // sets _env cache for non-string ref items
      return getCache( obj, '_env' );
    } );
  }
  return {
    effectiveType, artifactRef, inspectRef, queryOrMain,
    __getCache_forEnrichCsnDebugging: obj => cache.get( obj ),
  };

  /**
   * Return the type relevant for name resolution, i.e. the object which has a
   * `target`, `elements`, `enum` property, or no `type` property.  To avoid
   * confusion with the "base type", we do not use the term "final type".
   * (This function could be simplified if we would use JS prototypes for type refs.)
   *
   * @param {CSN.ArtifactWithRefs} art
   */
  function effectiveType( art ) {
    const cachedType = getCache( art, '_effectiveType' );
    if (cachedType !== undefined)
      return cachedType;
    else if (!art.type || art.elements || art.target || art.targetAspect || art.enum)
      return setCache( art, '_effectiveType', art );

    const chain = [];
    while (getCache( art, '_effectiveType' ) === undefined && art.type &&
           !art.elements && !art.target && !art.targetAspect && !art.enum) {
      chain.push( art );
      setCache( art, '_effectiveType', 0 ); // initial setting in case of cycles
      art = artifactRef( art.type, BUILTIN_TYPE );
    }
    if (getCache( art, '_effectiveType' ) === 0)
      throw new Error( 'Circular type reference');
    const type = getCache( art, '_effectiveType' ) || art;
    chain.forEach( a => setCache( a, '_effectiveType', type ) );
    return type;
  }

  /**
   * @param {CSN.Artifact} art
   */
  function navigationEnv( art ) {
    let type = effectiveType( art );
    // here, we do not care whether it is semantically ok to navigate into sub
    // elements of array items (that is the task of the core compiler /
    // semantic check)
    while (type.items)
      type = type.items;
    // cannot navigate along targetAspect!
    return (type.target) ? csn.definitions[type.target] : type;
  }

  /**
   * Return the object pointing to by the artifact reference (in 'type',
   * 'includes', 'target', raw 'from').
   *
   * @param {CSN.ArtifactReferencePath|string} ref
   * @param {any} [notFound] Value that is returned in case the artifact reference
   *                         could not be found.
   */
  function artifactRef( ref, notFound ) {
    const art = (typeof ref === 'string')
      ? csn.definitions[ref]
      : cached( ref, '_ref', artifactPathRef );
    if (art)
      return art;
    if (notFound !== undefined)
      return notFound;
    throw new Error( 'Undefined reference' );
  }

  function artifactPathRef( ref ) {
    const [ head, ...tail ] = ref.ref;
    let art = csn.definitions[pathId( head )];
    for (const elem of tail)
      art = navigationEnv( art ).elements[pathId( elem )];
    return art;
  }

  /**
   * Return the entity we select from
   *
   * @param {CSN.ArtifactReferencePath} ref
   * @returns {CSN.Definition}
   */
  function fromRef( ref ) {
    return navigationEnv( artifactRef( ref ));
  }

  /**
   * @param {CSN.Path} csnPath
   *
   * - return value `scope`
   *   global: first item is name of definition
   *   param:  first item is parameter of definition (with param: true)
   *   parent: first item is elem of parent (definition or outer elem)
   *   target: first item is elem in target (for keys of assocs)
   *   $magic: magic variable (path starts with $magic, see also $self)
   *   // now values only in queries:
   *   mixin:  first item is mixin
   *   alias:  first item is table alias
   *   $self:  first item is $self or $projection
   *   source: first item is element in a query source
   *   query:  first item is element of current query
   *   ref-target: first item is element of target of outer ref item
   *           (used for filter condition)
   *   expand: ref is "path continuation" of an EXPAND
   *   inline: ref is "path continuation" of an INLINE
   */
  function inspectRef( csnPath ) {
    return analyseCsnPath( csnPath, csn, resolveRef );
  }

  function resolveRef( obj, parent, query, scope, baseEnv, main ) {
    const path = (typeof obj === 'string') ? [ obj ] : obj.ref;
    if (!Array.isArray( path ))
      throw new Error( 'Value references must look like {ref:[...]}' );

    const head = pathId( path[0] );
    if (obj.param)
      return expandRefPath( path, main.params[head], 'param' );

    const spec = scopeSpecs[scope] || {};
    if (spec.global || obj.global)
      return expandRefPath( path, csn.definitions[head], 'global', scope === 'from' );

    cached( main, '$queries', allQueries );
    let qenv = query && cache.get( query.projection || query );
    // BACKEND ISSUE: you cannot call csnRefs(), inspect some refs, change the
    // CSN and again inspect some refs without calling csnRefs() before!
    // WORKAROUND: if no cached query, a backend has changed the CSN - re-eval cache
    if (query && !qenv) {
      setCache( main, '$queries', allQueries( main ) );
      qenv = cache.get( query.projection || query );
    }
    // first the lexical scopes (due to query hierarchy) and $magic: ---------
    if (spec.lexical !== false) {
      const tryAlias = path.length > 1 || obj.expand || obj.inline;
      let env = (qenv && spec.lexical) ? spec.lexical( qenv ) : qenv;
      while (env) {
        const alias = tryAlias && env.aliases[head];
        if (alias)
          return expandRefPath( path, alias._select || alias, 'alias', env.$queryNumber );
        const mixin = env._select.mixin && env._select.mixin[head];
        if (mixin && {}.hasOwnProperty.call( env._select.mixin, head ))
          return expandRefPath( path, mixin, 'mixin', env.$queryNumber );
        env = env.$next;
      }
      if (head.charAt(0) === '$') {
        if (head !== '$self' && head !== '$projection')
          return { scope: '$magic' };
        const self = qenv && qenv.$queryNumber > 1 ? qenv._select : main;
        return expandRefPath( path, self, '$self' );
      }
    }
    // now the dynamic environment: ------------------------------------------
    if (spec.dynamic === 'target') { // ref in keys
      // not selecting the corresponding element for a select column works,
      // because explicit keys can only be provided with explicit redirection
      // target
      const target = csn.definitions[parent.target || parent.cast.target];
      return expandRefPath( path, target.elements[head], 'target' );
    }
    if (baseEnv)                // ref-target (filter condition), expand, inline
      return expandRefPath( path, baseEnv.elements[head], scope );
    if (!query)                 // outside queries - TODO: items?
      return expandRefPath( path, parent.elements[head], 'parent' );

    if (spec.dynamic === 'query')
      // TODO: for ON condition in expand, would need to use cached _element
      return expandRefPath( path, qenv.elements[head], 'query' );
    for (const name in qenv.aliases) {
      const found = qenv.aliases[name].elements[head];
      if (found)
        return expandRefPath( path, found, 'source', name )
    }
    // console.log(query.SELECT,qenv,qenv.$next,main)
    throw new Error ( `Path item ${ 0 }=${ head } refers to nothing, scope: ${ scope }` );
  }

  /**
   * @param {CSN.Path} path
   * @param {CSN.Artifact} art
   * @param {string | null} [scope]
   */
  function expandRefPath( path, art, scope, extraInfo ) {
    /** @type {{idx, art?, env?}[]} */
    const links = path.map( (_v, idx) => ({ idx }) );
    // TODO: backends should be changed to enable uncommenting:
    // if (!art)    // does not work with test3/Associations/KeylessManagedAssociation/
    //   throw new Error ( `Path item ${ 0 }=${ pathId( path[0] ) } refers to nothing, scope: ${ scope }`);
    links[0].art = art;
    for (let i = 1; i < links.length; ++i) { // yes, starting at 1, links[0] is set above
      art = navigationEnv( art );
      links[i - 1].env = art;
      if (typeof path[i - 1] !== 'string')
        setCache( path[i - 1], '_env', art );
      art = art.elements[pathId( path[i] )];
      if (!art) {
        const env = links[i - 1].env;
        const loc = env.name && env.name.$location || env.$location;
        throw new Error ( `Path item ${ i }=${ pathId( path[i] ) } on ${ locationString( loc ) } refers to nothing` );
      }
      links[i].art = art;
    }
    const last = path[path.length - 1];
    const fromRef = scope === 'global' && extraInfo;
    if (fromRef || typeof last !== 'string') {
      const env = navigationEnv( art );
      links[links.length - 1].env = env;
      if (fromRef)
        art = env;
      if (typeof last !== 'string')
        setCache( last, '_env', env )
    }
    return (extraInfo && !fromRef)
      ? { links, art, scope, $env: extraInfo }
      : { links, art, scope };
  }

  /**
   * Get the array of all (sub-)queries (value of the `SELECT`/`projection`
   * property) inside the given `main` artifact (of `main.query`).
   *
   * @param {CSN.Definition} main
   * @returns {CSN.Query[]}
   */
  function allQueries( main ) {
    const all = [];
    const projection = main.query || main.projection && main;
    if (!projection)
      return null;
    traverseQuery( projection, null, null, function memorize( query, fromSelect, parentQuery ) {
      if (query.ref) {          // ref in from
        // console.log('SQ:',query,cache.get(query))
        const as = query.as || implicitAs( query.ref );
        getCache( fromSelect, 'aliases' )[as] = fromRef( query );
      }
      else {
        const qenv = initQueryEnv( query !== main && query, parentQuery );
        if (fromSelect)
          getCache( fromSelect, 'aliases' )[query.as] = qenv;
        const select = query.SELECT || query.projection;
        if (select) {
          cache.set( select, qenv ); // query and query.SELECT have the same cache qenv
          qenv._select = select;
          all.push( qenv );
        }
      }
    } );
    all.forEach( function initElements( qenv, index ) {
      qenv.$queryNumber = index + 1;
      qenv.elements = (index ? qenv._select : main).elements;
      const columns = qenv._select.columns;
      if (qenv.elements && columns)
        columns.map( c => initColumnElement( c, qenv ) );
    } );
    return all;
  }

  function initQueryEnv( query, parentQuery ) {
    let qenv; // = query && cache.get( query )
    // if (qenv)
    //   return qenv;
    const penv = parentQuery && parentQuery.SET && cache.get( parentQuery );
    if (penv && !penv._select) {       // SELECT not yet reached
      qenv = penv;                     // for leading query
    }
    else {
      qenv = { aliases: Object.create(null) };
      if (parentQuery)
        qenv.$next = cache.get( parentQuery );
    }
    if (query)
      cache.set( query, qenv );
    return qenv;
  }

  function initColumnElement( col, parentElementOrQueryEnv ) {
    if (col === '*')
      return;
    if (col.inline) {
      col.inline.map( c => initColumnElement( c, parentElementOrQueryEnv ) );
      return;
    }
    setCache( col, '_parent',   // not set for query (has property _select)
              !parentElementOrQueryEnv._select && parentElementOrQueryEnv );
    const as = col.as || col.func || implicitAs( col.ref );
    let type = parentElementOrQueryEnv;
    while (type.items)
      type = type.items;
    const elem = setCache( col, '_element', type.elements[as] );
    // if requested, we could set a _column link in element
    if (col.expand)
      col.expand.map( c => initColumnElement( c, elem ) );
  }

  // property name convention in cache:
  // - $name: to other cache object (with proto), dictionary (w/o proto), or scalar
  // - _name, name: to CSN object value (_name) or dictionary (name)

  function setCache( obj, prop, val ) {
    let hidden = cache.get( obj );
    if (!hidden) {
      hidden = {};
      cache.set( obj, hidden );
    }
    hidden[prop] = val;
    return val;
  }

  function getCache( obj, prop ) {
    const hidden = cache.get( obj );
    return hidden && hidden[prop];
  }

  function cached( obj, prop, calc ) {
    let hidden = cache.get( obj );
    if (!hidden) {
      hidden = {};
      cache.set( obj, hidden );
    }
    else if (hidden[prop] !== undefined)
      return hidden[prop];
    const val = calc( obj );
    hidden[prop] = val;
    return val;
  }
}

// Return value of a query SELECT for the query node, or the main artifact,
// i.e. a value with an `elements` property.
/**
 * @param {CSN.Query} query node (object with SET or SELECT property)
 * @param {CSN.Definition} main
 */
function queryOrMain( query, main ) {
  while (query.SET)
    query = query.SET.args[0];
  if (query.SELECT && query.SELECT.elements)
    return query.SELECT;
  let leading = main.query || main;
  while (leading.SET)
    leading = leading.SET.args[0];
  // If an entity has both a projection and query property, the param `query`
  // can be the entity itself (when inspect is called with a csnPath containing
  // 'projection'), but `leading` can be its `query` property:
  if ((leading === query || leading === query.query) && main.elements)
    return main;
  throw new Error( `Query elements not available: ${ Object.keys( query ).join('+') }`);
}

/**
 * Traverse query in pre-order
 *
 * @param {CSN.Query} query
 * @param {CSN.QuerySelect} fromSelect
 * @param {(query: CSN.Query&CSN.QueryFrom, select: CSN.QuerySelectEnriched) => void} callback
 */
function traverseQuery( query, fromSelect, parentQuery, callback ) {
  if (query.SELECT || query.projection) {
    callback( query, fromSelect, parentQuery );
    const select = query.SELECT || query.projection;
    traverseFrom( select.from, select, parentQuery, callback );
    for (const prop of [ 'columns', 'where', 'having' ]) {
      // all properties which could have sub queries
      const expr = select[prop];
      if (expr)
        expr.forEach( q => traverseExpr( q, query, callback ) );
    }
  }
  else if (query.SET) {
    callback( query, fromSelect, parentQuery );
    const { args } = query.SET;
    for (const q of args || []) {
      if (q === args[0])        // leading query
        traverseQuery( q, fromSelect, query, callback );
      else
        traverseQuery( q, null, query, callback );
    }
  }
}

/**
 * @param {CSN.QueryFrom} from
 * @param {CSN.QuerySelect} select
 * @param {(from: CSN.QueryFrom, select: CSN.QuerySelect) => void} callback
 */
function traverseFrom( from, fromSelect, parentQuery, callback ) {
  if (from.ref) {
    callback( from, fromSelect, parentQuery );
  }
  else if (from.args) {         // join
    from.args.forEach( arg => traverseFrom( arg, fromSelect, parentQuery, callback ) );
    if (from.on)                // join-on, potentially having a sub query
      from.on.forEach( arg => traverseQuery( arg, null, fromSelect, callback ) );
  }
  else {                        // sub query in FROM
    traverseQuery( from, fromSelect, parentQuery, callback );
  }
}

function traverseExpr( expr, parentQuery, callback ) {
  if (expr.SELECT || expr.SET)
    traverseQuery( expr, null, parentQuery, callback )
  for (const prop of [ 'args', 'xpr' ]) {
    // all properties which could have sub queries (directly or indirectly),
    const val = expr[prop];
    if (val && typeof val === 'object') {
      const args = Array.isArray( val ) ? val : Object.values( val );
      args.forEach( e => traverseExpr( e, parentQuery, callback ) );
    }
  }
}

function pathId( item ) {
  return (typeof item === 'string') ? item : item.id;
}

function implicitAs( ref ) {
  const id = pathId( ref[ref.length - 1] );
  return id.substring( id.lastIndexOf('.') + 1 );
}

/**
 * @param {CSN.Path} csnPath
 * @param {CSN.Model} csn
 */
function analyseCsnPath( csnPath, csn, resolve ) {
  if (csnPath[0] !== 'definitions')
    throw new Error( 'References outside definitions not supported yet');

  /** @type {object} */
  let obj = csn;
  let parent = null;
  let query = null;
  let scope = null;
  let art = null;
  /** @type {boolean|string|number} */
  let isName = false;
  let refObj = null;
  let baseEnv = null;

  for (let index = 0; index < csnPath.length; index++) {
    const prop = csnPath[index];
    // array item, name/index of artifact/member, (named) argument
    if (isName || Array.isArray( obj )) {
      if (typeof isName === 'string') {
        parent = art;
        art = obj[prop];
      }
      isName = false;
    }
    else if (artifactProperties.includes( String(prop) )) {
      isName = prop;
      scope = prop;
    }
    else if (prop === 'items' || prop === 'returns') {
      art = obj[prop];
    }
    else if (prop === 'args') {
      isName = true;            // for named arguments
    }
    else if (prop === 'SELECT' || prop === 'SET' || prop === 'projection') {
      query = obj;
      parent = null;
      scope = prop;
    }
    else if (prop === 'where' && scope === 'ref') {
      if (resolve)
        baseEnv = resolve.refWhere( refObj, obj, parent, query, scope, baseEnv,
                                    csn.definitions[csnPath[1]] );
      scope = 'ref-target';
    }
    else if (prop === 'expand' || prop === 'inline') {
      if (obj.ref) {
        if (resolve)
          baseEnv = resolve.expand( obj, parent, query, scope, baseEnv,
                                    csn.definitions[csnPath[1]] );
        scope = prop;
      }
      if (prop === 'expand')
        isName = prop;
    }
    else if (prop === 'on') {
      if (scope === 'from')
        scope = 'join-on';
      else if (scope === 'mixin')
        scope = 'mixin-on';
      else
        scope = 'on';           // will use query elements with REDIRECTED TO
    }
    else if (prop === 'ref') {
      refObj = obj;
      scope = prop;
    }
    else if (prop === 'orderBy') {
      scope = (query.SET ? 'orderBy-set' : 'orderBy');
    }
    else if (prop !== 'xpr') {
      scope = prop;
    }

    obj = obj[prop];
    if (!obj && !resolve)
      // For the semantic location, use current object as best guess
      break;
  }
  // console.log( 'CPATH:', csnPath, scope, obj, parent.$location );
  if (!resolve)
    return { query };           // for constructSemanticLocationFromCsnPath
  return resolve( obj, parent, query, scope, baseEnv, csn.definitions[csnPath[1]] );
}

module.exports = {
  csnRefs,
  traverseQuery,
  artifactProperties,
  implicitAs,
  analyseCsnPath,
  pathId,
};
